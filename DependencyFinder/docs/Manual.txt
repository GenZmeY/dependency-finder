---+ The Dependency Finder User Manual

by Jean Tessier

----

<TOC />

----

---++ Introduction

This application extracts information from compiled Java code and makes
it available to users in a numbers of ways.

Many authors have stressed the importance of managing depencencies
([[http://www.objectmentor.com/resources/listArticles?key%3Dauthor&author%3DRobert%20C.%20Martin][Robert C. Martin]],
[[http://www.amazon.com/exec/obidos/ASIN/0201633620/o/qid%3D980962318/sr%3D8-1/ref%3Daps%5Fsr%5Fb%5F1%5F1/105-0176284-9920776][John Lakos]]).
Managing
dependencies means securing encapsulation and making sure that the code
follows the architecture.  It is also essential for the modularization of
code and favors reuse.  By extracting the information from the code itself,
we can detect where we were sloppy, where we took shortcuts that we
shouldn't have.  Managing the dependencies can shorten the compilation time
of the code.

This application also includes tools for computing metrics based on
information extracted from compiled Java code.  These measurements can be
helpful to guide development and can point out areas where the code needs
improvement.

Finally, this application includes a tool that computes the changes in the
API of a system between successive versions.  If you use third-party
libraries, you can use it to verity that the parts you are dependending
upon have not changed.  If you provide libraries to others, you can use it
to assertain the impact changes might have on your customers.  You can even
use it to monitor the evolution of your own software.

---+++ History Behind Dependency Finder

This project started because another project of mine became so complex that
I couldn't track dependencies in my head anymore.  I looked for a tool to
help me and the only ones I could find were very expensive.  So I resolved
to build my own tool.

I haven't touched that other project since I started working on Dependency
Finder.

At first, I thought of using the Reflection API, but it shows only the
class's attributes and method signatures.  If a method uses other classes
as part of its processing, the Reflection API will not show that dependency.

Java compilers take source code and produce bytecode that they put in
=.class= files.  The format of these files is described in
[[http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html][The =class= File Format]].
I undertook to parse these files and extract the information I needed
directly from the compiled code.

Once I had access to the code structure, I got started on tools to report
_interesting_ information about it.  I started with dependencies and
quickly moved up to metrics and API differences.  At the beginning, the
output was only to standard output or a file.  Quickly, I added XSL
stylesheets so it would look a little better.  Eventually, I added Swing
application to keep the data in memory and play with it a while.

----

---++ Installation

---+++ Java Application on Windows

Dependency Finder comes as a ZIP file that includes everything you need
to run it.

---++++ Step 1: Java Virtual Machine

You need to have a Java Virtual Machine installed.  You can get one for
free from [[http://java.sun.com/][Sun Microsytems]].  Make sure you define
the =JAVA_HOME= environment variable.

For example, if you installed JDK 1.3 in =C:\jdk1.3=:

    SET JAVA_HOME=C:\jdk1.3

You can either add this line to your =AUTOEXEC.BAT= file, or on WinNT
use Start | Settings | Control Panel | System and select the Environment
tab to create and edit variables.

---++++ Step 2: Deploy Dependency Finder

Extract the ZIP file to some directory you like.  The extraction will
create a subdirectory named "DependencyFinder" that is the root of the
package.

For example, if you extract it to =C:\=, you will endup with a
directory called =C:\DependencyFinder\=.

---++++ Step 3: Environment Variables

<i>This is only required on Win95/98.  Under WinNT, the scripts are smart
enough to find out where you installed Dependency Finder on their own.</i>

Create an environment variable named =DEPENDENCYFINDER_HOME= and have it
point to the directory where you installed Dependency Finder.

For example, if you extracted the ZIP file in =C:\=

    SET DEPENDENCYFINDER_HOME=C:\DependencyFinder

You can either enter this line in your =AUTOEXEC.BAT= file, or on WinNT
use Start | Settings | Control Panel | System and select the Environment
tab to create and edit variables.

---++++ Step 4: =PATH=

Add the "bin" subdirectory to your =PATH= variable.

For example, if you extracted the ZIP file in =C:\=

    SET PATH=C:\DependencyFinder\bin;%PATH%

---++++ Step 5: Reboot

_This is only required on Win95/98._

Under Win95/98, you will need to reboot your computer for the changes to the
environment to take effect.

---++++ Miscellaneous

If the VM runs out of memory, try setting the =DEPENDENCYFINDER_OPTS=
environment variable.

    SET DEPENDENCYFINDER_OPTS=-Xmx128m

If you get the message "Out of environment space" while running the scripts
on a Windows machine, you will need to add the following line to your
=C:\CONFIG.SYS= file and then reboot.

    shell=command.com /e:8192 /p

This reserves more space for environment variables in the DOS shell. You can
type:

    C:\>command /?

for more details.

---+++ Java Application on Unix

At this time, Dependency Finder does not have shell scripts to launch any
of the tools the way it does under DOS.

---++++ Step 1: Java Virtual Machine

You need to have a Java Virtual Machine installed.  You can get one for
free from Linux or Solaris from [[http://java.sun.com/][Sun Microsytems]].
Make sure you define the =JAVA_HOME= environment variable.

Suppose you installed JDK 1.3 in =/usr/java=.

For sh or bash:

    JAVA_HOME=/usr/java
    export JAVA_HOME

For csh or tcsh:

    setenv JAVA_HOME /usr/java

You can put this line in your =.cshrc= file.

---++++ Step 2: Deploy Dependency Finder

Extract the ZIP file to some directory you like.  The extraction will
create a subdirectory named "DependencyFinder" that is the root of the
package.

    $ unzip DependencyFinder.zip

For example, if you extract it to =$HOME=, you will endup with a
directory called =$HOME/DependencyFinder/=.

---++++ Step 3: Environment Variables

Create an environment variable named =DEPENDENCYFINDER_HOME= and have it
point to the directory where you installed Dependency Finder.

If the VM runs out of memory, try modifying the =DEPENDENCYFINDER_OPTS=
environment variable to allocate more memory to the JVM.

Suppose you extracted the ZIP file in =$HOME=.

For sh or bash:

    DEPENDENCYFINDER_HOME=$HOME/DependencyFinder
    export DEPENDENCYFINDER_HOME
    DEPENDENCYFINDER_OPTS=-Xmx128m
    export DEPENDENCYFINDER_OPTS

For csh or tcsh:

    setenv DEPENDENCYFINDER_HOME $HOME/DependencyFinder
    setenv DEPENDENCYFINDER_OPTS -Xmx128m

You can put these lines in your =.cshrc= file.

---++++ Step 4: =PATH=

Add the directory where you put the Unix scripts to your =PATH= variable.

Suppose you extracted the ZIP file in =$HOME=.

For sh or bash:

    PATH=$DEPENDENCYFINDER_HOME\bin;$PATH
    export PATH

For csh or tcsh:

    set path = ($DEPENDENCYFINDER_HOME\bin $path)

You can put this line in your =.cshrc= file.

---+++ Web Application

Dependency Finder also comes as a web application that you can easily deploy
in just about any J2EE servlet container.

---++++ Step 1: Deploy WAR File

Use your favorite servlet container to deploy the WAR file.  Most of them
have tools for deploying WAR files.  For some of them, it can be as simple
as deploying the WAR file to a specific directory.

For instance, under Tomcat on Windows:

    C:\>%CATALINA_HOME%\bin\shutdown
    C:\>copy DependencyFinder.war %CATALINA_HOME%\webapps
    C:\>%CATALINA_HOME%\bin\startup

---++++ Step 2: Configure =web.xml= file

Next, you need to tell the wep application where to find the Java classes to
extract dependencies from.  This is done via the =web.xml= file in the
=WEB-INF\= directory.  Some application servers expose the content of this
file through some form of user interface.  Under Tomcat, you have to edit
the file yourself using a text editor.

There are three application variable to adjust.

<blockquote>
<table border="0"
       cellpadding="5">
    <tr>
	<td valign="top">
	    *=name=*
	</td>
	<td>
	    Used in the JSPs to tell the users what that are looking at.
	    Put the name of the application that you are extracting from
	    here, it will be shown in titles by the JSPs.
	</td>
    </tr>
    <tr>
	<td valign="top">
	    *=source=*
	</td>
	<td>
	    Use this variable to tell Dependency Finder where to locate
	    classes find which to extract a dependency graph.  You can
	    separate multiple locations by using commas.  Each location
	    can either be a JAR file, a ZIP file, a =.class= file, or a
	    directory that will be recursively searched for =.class= files.
	</td>
    </tr>
    <tr>
	<td valign="top">
	    *=mode=*
	</td>
	<td>
	    Optional.  Tells Dependency Finder whether to _minimize_ or
	    _maximize_ the resulting graph, or just leave it alone (_raw_,
	    the default value).  See below for the implications of
	    minimizing or maximizing a graph.
	</td>
    </tr>
</table>
</blockquote>

Under some servlet containers, for example Tomcat, you will need to restart
the servlet container for the changes to take effect.

    C:\>%CATALINA_HOME%\bin\shutdown
    C:\>%CATALINA_HOME%\bin\startup

Or you can you the deployment tool in Tomcat Manager to install the web
application.

----

---++ Running Dependency Finder

Once you have installed Dependency Finder, you are ready to use all the
tools now at your disposal.  Almost all of them are Java applications that
you launch using a batch file or shell script.

At the beginning, the toolset was just a group of batch files that
offered a basic command-line interface (CLI).  Later, I added a Swing
graphical interface (GUI) that simply replicated the controls available
through the CLI.  Finally, I build a web application that mirrored the
GUI.  This might help explain why the the interface looks the way it
does and why it may not always be very intuitive.

We will start with the GUI-based tools, and then talk about the CLI-based
tools.

All the tools support the following two command-line switches:

<blockquote>
<table border="0"
       cellpadding="5">
    <tr>
	<td valign="top"
	    nowrap="true">
	    =-help=
	</td>
	<td>
	    Prints the list of valid command-line switches for that
	    particular tool.
	</td>
    </tr>
    <tr>
	<td valign="top"
	    nowrap="true">
	    =-verbose [filename]=
	</td>
	<td>
	    Writes summary processing information to _filename_.  If you do
	    not specify a file, the tool will write the information to the
	    standard output stream.
	</td>
    </tr>
</table>
</blockquote>

Many of the tools also support some or all of the following three
command-line switches:

<blockquote>
<table border="0"
       cellpadding="5">
    <tr>
	<td valign="top"
	    nowrap="true">
	    =-in=
	</td>
	<td>
	    Many of the CLI tools are automated translations of XML data
	    into either HTML or plain text.  The scripts have hard-coded
	    XSL stylesheets.  You specify the XML input with this switch.
	</td>
    </tr>
    <tr>
	<td valign="top"
	    nowrap="true">
	    =-out filename=
	</td>
	<td>
	    Writes the output of the command to _filename_.  Most commands
	    default to the standard output if you do not use =-out=.
	</td>
    </tr>
    <tr>
	<td valign="top"
	    nowrap="true">
	    =-time=
	</td>
	<td>
	    Prints the time it took to run the command.  If you run commands
	    against a large codebase or dependency graph, it can take a
	    substantial amount of time before it returns.  This information
	    can help you plan lenghty operations in the future.
	</td>
    </tr>
</table>
</blockquote>

---+++ GUI

The main tool is =DependencyFinder=.  It extracts dependencies from
compiled code, maintains the dependency graph in memory, and provides
an interface for querying the graph and display the results.

<div align="center">
    [[images/DependencyFinder.query.jpg][images/s_DependencyFinder.query.jpg]]
*DependencyFinder*
</div>

The other tool computes metrics on a given codebase.  It displays
results in a table with sortable columns.  Different tabs control the
level of detail: package, class, or method.

<div align="center">
    [[images/OOMetricsGUI.sample.jpg][images/s_OOMetricsGUI.sample.jpg]]
*OOMetricsGUI*
</div>

---+++ CLI

<div align="center">
    [[images/Flow.gif]]
*Document Flow*
</div>

----

---++ Class Files

Dependency Finder uses specialized classes to parse =.class= files.  It also
includes some tools for looking at the contents of these files.

---+++ ClassReader

Use this tool to put the class in a =.class= file in human-readable form.
With the =-xml= switch, it dumps the complete structure to an XML file
that you can manipulate with your favorite XML editor.

---+++ ClassMetrics

This is a simple tally of how many classses, interfaces, methods, publics,
statics, finals, etc. there are in a given codebase.  These tallies are
not as powerful as the metrics of =OOMetrics=, but they can give you a
rough idea of the size and complexity of a piece of software.

----

---++ Dependencies

Dependencies occur when one class uses the services of another class.  For
example, this can happen when a class inherits from another, has an attribute
whose type is of another class, or when one of its methods calls a method on
an object of another class.

Knowing about dependencies is useful for programmers when deciding the
impact of a change.  When you're about to rename a feature or class, it is
useful to know all the places in the codebase where it is being used.

This is also useful for code reviewers and architects when assessing the
coupling within an application or library.

Dependency Finder builds dependency graphs based on the information in
class files.

So, a dependency is when the functioning of one element =A= requires the
presence of another element =B=.  We say that =A= _depends_ on =B= and we
write it:

    A --> B

We say that =A= has an _outbound_ dependency while =B= has an _inbound_
dependency.  It is the same dependency, but whether it is inbound or
outbound is relative to how you look at it.  We also say that =A= is a
_dependent_ and =B= is _dependable_.

A dependency graph comprises nodes for software artifacts linked
together by two types of relationships.  Artifacts are packages,
classes, and features.  We use the term _feature_ to designate
class attributes, constructors, and methods; we will be treating
them the same from here on.  For the purpose of analyzing dependencies,
we do not distinguish between different types of features, whether they
are constructors or regular methods, and regardless of the feature's
characteristics, such as being marked as =final= or =static=.

Packages have classes, which themselves have features; this is called
_composition_.  Classes refer to each other and so do features; this is
called a _dependency_.

So a feature node is linked to its class node through composition.
The class node is also linked to its package node through
composition.  Each is linked to various other nodes of various type
using dependency links.

---+++ Extracting

Going through class files and collecting dependencies is called
_extracting_.  The application keeps dependencies in a graph.  It
begins with one node per Java package.  To this it adds one node
per Java class (including inner classes), and to those it adds
one node per feature.

Dependency Finder can read all types of compiled Java: JAR files,
ZIP files, or class files.  You can point it to a JAR, ZIP, or
=.class= file.  You can also point it to a directory and it will
explore that directory and all its subdirectories for files ending
in =.class=.  You can select more than one target, mix and match
JARs and ZIPs and class files and directories, and Dependency
Finder will aggregate all their contents together.  It will sort
them all out.

The dependencies are gathered by the class
=com.jeantessier.dependency.CodeDependencyCollector=.  It traverses
the structure of a =.class= file, as read by
=com.jeantessier.classreader.Classfile=, and collects explicit
dependencies in the bytecode.

The dependency collector can detect three kinds of explicit
dependencies, from which Dependency Finder can infer all implicit
dependencies:

    1 feature to feature
    1 feature to class
    1 class to class

<div align="center">
    [[images/ExplicitImplicit.gif]]
*Explicit and Implicit Dependencies*
</div>

There are _explicit_ dependencies, as present in the code itself.  There
are also _implicit_ dependencies derived from these explicit ones.  A
dependency between two classes in two separate packages _implies_ a
dependency between the packages.

---++++ Limitations

Dependency Finder analyzes compiled Java code, and as a result it is at the
mercy of the information produced by the compiler.  Some of the following
limitations are the result of using Sun's compiler that comes with the JDK.
But I will start with one limitation that applies regardless of the compiler.

---+++++ Dependencies on Self

If we look closely at this model, we see that recursive method calls and
certain types of recursive structures can generate dependencies between
a programming elemend (i.e., a class or a method) and itself.  Or, if a
method has a parameter or local variable whose type is the enclosing
class itself, or if an attribute's type is its enclosing class, this
introduce a dependency from the feature to the class of which it is a
part of.

<div align="center">
    [[images/SelfDependency.gif]]
*Dependencies on Self*
</div>

Dependency Finder does not keep track of dependencies on self.  Dependency
analysis is useful for two things:

   1 Compile-time dependencies
   1 Runtime dependencies

You use compile-time dependency, or change impact analysis, to answer
questions such as "If I change X, what else might I have to change too?"
Dependencies on self are not all that useful here.  If I am changing X,
I don't need to be told that X will be impacted.  Likewise, if I am making
changes to features of a class, I don't need to be told that the class
will be impacted; I am already editing it.  I do, however, need to know
what other features in this class might be impacted.

You use runtime dependency analysis to answer questions such as "For class
X to run, what other classes do I need?"  The class as a whole is the unit
of loading.  If a feature needs its class, the class is forcibly already
loaded otherwise the JVM would never had gotten to the feature to begin
with.  Likewise, if a class needs itself, well it is already there.

So Dependency Finder does not keep track of dependencies on self.  This
includes implicit dependencies from a class or feature to its package, or
from a package to itself.

---+++++ Constants

It is often the case that Dependency Finder cannot track dependencies on
simple =static final= constants.

In Java, you can define constants in classes and interfaces by marking them
as =static= and =final=.  Subclasses or implementations cannot override the
constants because they are static.  No one can change the value because it
is final.  As a result, the compiler can use local optimizations to speed up
execution.  When these constants are of primitive types or =String=, the
compiler can inline the value directly in the client class, so that it makes
no reference at all to the class that owns the constant.

Under these circumstances, Dependency Finder cannot track dependencies on
simple constants that are referenced from outside their class.  If the
constant are of some object type other than =String=, the compiler cannot
perform the optimization and Dependency Finder will be able to track
dependencis on them.

---+++++ Local Variables

Dependency Finder does not track the type of local variables in methods.

The compiler does not need to keep track of the type of local variables.  It
validates the assignment and then discards type information.  The virtual
machine will validate the bytecode and make sure that it was not tampered
with.  The compiler makes sure that an assignment to a local variable is
type-safe.  Any method call on the variable will be made either on an
interface or a class that is compatible with the type of the local variable.

Most compilers have options to retain information about local variables,
such as their name and type.  With =javac=, you have to supply the =-g=
switch.  Doing this helps symbolic debuggers give more useful context
information to their users.

Given all this, it barely matters if Dependency Finder tracks dependencies
on the type of local variables very closely.  Assignments will to objects
whose type eventually reaches the exact type of the variable, and method
calls will be made on that type's set of methods.  Dependency Finder loses
no information by ignoring possible local variables, just a little precision.
And since the virtual machine does not use that information, it does not
impact runtime dependencies anyway.

---++++ Extracting With the GUI

<div align="center">
    [[images/DependencyFinder.extract.high.jpg][images/s_DependencyFinder.extract.high.jpg]]
*Extract Dialog*
</div>

Select =File&nbsp;|&nbsp;Extract=; this will popup a file dialog.
Select the files and/or directories to extract from and click =Extract=.
You can repeat this command as often as needed; each time, the extracted
dependencies will be added to the current dependency graph in memory.

You can save the current dependency graph to an XML file by using
=File&nbsp;|&nbsp;Save=.  You can later reload the graph by using
=File&nbsp;|&nbsp;Open=.  Note that it is usually faster to extract the
information again from class files than to load it from an XML file.

---++++ Extracting With the CLI

You use =DependencyExtractor= to extract dependencies.  Simply string
out the files and directories on the command line.  All the dependencies
are merged into a single output.

E.g.,

    C:\>DependencyExtractor classes %JAVA_HOME%\JRE\lib\rt.jar

You can specify an output file with the =-out= switch:

    C:\>DependencyExtractor %DEPENDENCYFINDER_HOME%\lib\DependencyFinder.jar -out df.txt

You can save the graph to XML with the =-xml= switch:

    C:\>DependencyExtractor %DEPENDENCYFINDER_HOME%\lib\DependencyFinder.jar -xml -out df.xml

Or you can use Java serialization to save the graph:

    C:\>DependencyExtractor %DEPENDENCYFINDER_HOME%\lib\DependencyFinder.jar -serialize -out df.ser

<dl>
    <dt>NOTE:</dt>
    <dd><i>At this time, Dependency Finder cannot deserialize the graph
    back.</i></dd>
</dl>

---+++++ Example

Here is a simple, concrete example.  We start with a trivial Java class in
the file =test.java= and compiled into =test.class=.

    import java.util.*;
    
    public class test {
        public static void main(String[] args) {
            Collection c = Collections.singleton(new Object());
        }
    }

Here is the raw output dependency graph.

    C:\>DependencyExtractor test.class
    
        test
            --> java.lang.Object
            main(java.lang.String[])
                --> java.lang.Object
                --> java.lang.Object.Object()
                --> java.lang.String
                --> java.util.Collections.singleton(java.lang.Object)
                --> java.util.Set
            test()
                --> java.lang.Object.Object()
    java.lang
        Object
            <-- test
            <-- test.main(java.lang.String[])
            Object()
                <-- test.main(java.lang.String[])
                <-- test.test()
        String
            <-- test.main(java.lang.String[])
    java.util
        Collections
            singleton(java.lang.Object)
                <-- test.main(java.lang.String[])
        Set
            <-- test.main(java.lang.String[])

We can save it to an XML document for use with the other tools.

    C:\>DependencyFinder -xml -out test.xml test.class

And narrow down the graph to class-to-class dependencies.

    C:\>c2c -scope-includes /test/ test.xml
    
        test
            --> java.lang.Object
            --> java.lang.String
            --> java.util.Collections
            --> java.util.Set

=c2c= is a shortcut for a set of switches to =DependencyReporter=.  All the
following commands are equivalent.

    C:\>c2c -scope-includes /test/ test.xml
    C:\>c2c -class-scope-includes /test/ test.xml
    C:\>DependencyReporter -c2c -class-scope-includes /test/ test.xml
    C:\>DependencyReporter -class-scope -class-scope-includes /test/ -class-filter test.xml

For fun, I entered manually entered this graph description into
[[http://www.gentleware.de/products/poseidonCE.php3][Poseidon for UML]].

<div align="center">
    [[images/ClassClassDependencies.test.jpg]]
*Class-to-Class Dependencies*
</div>

We can narrow the graph further to class-to-package dependencies.  Again, all
these commands are equivalent.

    C:\>c2p -scope-includes /test/ test.xml
    C:\>c2p -class-scope-includes /test/ test.xml
    C:\>DependencyReporter -c2p -scope-includes /test/ test.xml
    C:\>DependencyReporter -class-scope -class-scope-includes /test/ -package-filter test.xml
    
        test
            --> java.lang
            --> java.util

<div align="center">
    [[images/ClassPackageDependencies.test.jpg]]
*Class-to-Package Dependencies*
</div>

Finally, a package-to-package dependency graph.  All these commands are
equivalent.

    C:\>p2p test.xml
    C:\>DependencyReporter -p2p test.xml
    C:\>DependencyReporter -package-scope -package-filter test.xml
    
        --> java.lang
        --> java.util
    java.lang
        <-- 
    java.util
        <-- 

<div align="center">
    [[images/PackagePackageDependencies.test.jpg]]
*Package-to-Package Dependencies*
</div>

---++++ Extracting With the Web Application

You use =extract.jsp= to generate a dependency graph for the web application.
The graph will stay in memory for the lifetime of the process serving the
application, or until you extract it again with the JSP.  This graph can
get pretty big, so make sure you allocate enough memory to the application
server.

If you just call =extract.jsp=, it will print statistics on the current
graph, if any.  These include the number of nodes in the graph, how long
it took to extract it, and a timestamp of when it was extracted.

If you click on the _Launch_ button, or call =extract.jsp?launch%3DLaunch=,
it will start to extract a new dependency graph.  The previous one will
remain in use for other callers until the extraction terminates successfully.
The JSP prints the name of classes as it extracts them.  And at the end, it
prints how many classes it read and how it it took to analyze them.

You can use the URL "=extract.jsp?launch%3DLaunch=" to automatically
update the graph after automated compilation runs, such as during nightly
builds.

    &lt;target name%3D"extract" depends%3D"init"&gt;
        &lt;get src%3D"${WEB%5FAPP%5FURL}/extract.jsp?launch%3DLaunch"
             dest%3D"log.html"/&gt;
    &lt;/target&gt;

---++++ Minimizing And Maximizing

It is often the case that an explicit dependency in the code can be implied
from another explicit dependency in that code.  For example, take the
following code snippet:

    class A extends B {
        public void a() {
            b();
        }
    }

    class B {
        public void b() {}
    }

We can analyze the dependencies.  =A= is a subclass of =B=, so there is a
dependency =A&nbsp;-->&nbsp;B=.  And =A.a()= calls =b()=, which is defined
in =B=, yielding the dependency =A.a()&nbsp;-->&nbsp;B.b()=.  Here is a
subset of the resulting dependency graph:

<div align="center">
    [[images/RedundantI.gif]]
*Raw*
</div>

Clearly, the dependency =A.a()&nbsp;-->&nbsp;B.b()= implies the dependency
=A&nbsp;-->&nbsp;B=.  We say that the latter is _redundant_; it does not
add anything to the overall connectivity of the graph.  Another, very
frequent, example of this situation occurs with constructors.

    class A extends B {}
    class B {}

<div align="center">
    [[images/RedundantII.gif]]
*Raw*
</div>

Another variation occurs when a method either calls a method on an object
it received as a parameter or throws a new =Exception= that is part of
its =throws= clause.

    class A {
        public void a(B b) {
            b.b();
        }
    }

    class B {
        public void b() {}
    }

<div align="center">
    [[images/RedundantIII.gif]]
*Raw*
</div>

We _minimize_ the dependency graph when we remove redundant dependencies.
In the first example above, we would remove the dependency
=A&nbsp;-->&nbsp;B=.  Here is what would be the resulting graph:

<div align="center">
    [[images/Minimized.gif]]
*Minimized*
</div>

We _maximize_ the dependency graph when we expose all implicit dependencies
by making them explicit.  Staying with our example,
=A.a()&nbsp;-->&nbsp;B.b()=, maximizing it would introduce these
dependencies:

    * =A.a()&nbsp;-->&nbsp;B=
    * =A&nbsp;-->&nbsp;B.b()=
    * =A&nbsp;-->&nbsp;B=

<div align="center">
    [[images/Maximized.gif]]
*Maximized*
</div>

Maximizing and minimizing a dependency graph deals with the trade off
between space and time.  Minimizing the graph saves on space, but it
takes longer to traverse the graph to find if there is a dependency
between two given nodes.  Maximizing the graph saves on time, since all
the dependencies are there for the picking, but the size of the graph
goes up dramatically.

The illustrations below show how combinations of these are minimized or
maximized.  You can minimize a graph that has been maximized and obtain
the same minimized graph as if you had minimized the original graph.
Similarily, if you maximize a graph that has been minimized, you end up
with the same graph as if you had minimized the original graph.

<div align="center">
    [[images/MinMaxTitle.gif]]
    [[images/MinMaxI.gif]]
    [[images/MinMaxII.gif]]
    [[images/MinMaxIII.gif]]
    [[images/MinMaxIV.gif]]
    [[images/MinMaxV.gif]]
    [[images/MinMaxVI.gif]]
    [[images/MinMaxVII.gif]]
    [[images/MinMaxVIII.gif]]
</div>

---+++++ Example

Here is a simple, concrete example.  We start with a our trivial Java class
from before.

    import java.util.*;
    
    public class test {
        public static void main(String[] args) {
            Collection c = Collections.singleton(new Object());
        }
    }

Let's start with the obvious dependencies.  =test.main()= has a parameter
that's a =String= array, a local variable of type =Collection=, calls the
no-arg constructor for =Object=, and calls a static method on =Collections=.
That's four so far.  Also, since =test= extends =Object= by default, that's
one more dependency.  It also gets an implicit no-arg constructor that calls
=Object='s no-arg constructor.  We are now up to six dependencies.

The compiler does not keep track of local variables unless you call it with
the =-g= switch.  This means we are not guaranteed to find the dependency
=test.main(java.lang.String[])&nbsp;-->&nbsp;java.util.Collection= by simply
looking at compiled code.  But we can examine the signature of =singleton()=
and since we have to call it, we'll need to get objects of these types.
The method takes a parameter of type =Object= and returns a =Set=.  This
last one makes up for our loosing =Collection= earlier since =Set= extends
=Collection=.

Total: seven dependencies.

<div align="center">
    [[images/RawTest.gif]]
*Raw*
</div>

The redundant dependencies are show in bold.  We can remove them by minimizing
the graph.

<div align="center">
    [[images/MinimizedTest.gif]]
*Minimized*
</div>

Or, we can maximize the graph.  The bold dependencies below show the original
dependencies.  If the graph gets this complicated for something as trivial as
=test.java=, imagine what your code will look like.

<div align="center">
    [[images/MaximizedTest.gif]]
*Maximized*
</div>

Here are the dimentions of various graphs.

<table border="3"
       rules="groups"
       cellpadding="3">
    <colgroup />
    <colgroup span="3" />
    <colgroup span="2" />
    <colgroup />
    <colgroup span="2" />
    <thead>
    <tr>
	<td valign="top"
	    rowspan="2">*Software*</td>
	<td align="center"
	    colspan="3">*Artifacts*</td>
	<td align="center"
	    colspan="5">*Dependencies*</td>
    </tr>
    <tr>
	<td align="center">*Packages*</td>
	<td align="center">*Classes*</td>
	<td align="center">*Features*</td>
	<td align="center"
	    colspan="2">*Minimized*</td>
	<td align="center">*Raw*</td>
	<td align="center"
	    colspan="2">*Maximized*</td>
    </tr>
    </thead>
    <tbody>
    <tr>
	<td>=test.java=</td>
	<td align="right">3</td>
	<td align="right">5</td>
	<td align="right">4</td>
	<td align="right">5</td>
	<td align="right">(-29%)</td>
	<td align="right">7</td>
	<td align="right">27</td>
	<td align="right">(+286%)</td>
    </tr>
    </tbody>
    <tbody>
    <tr>
	<td>Jakarta-ORO</td>
	<td align="right">9</td>
	<td align="right">101</td>
	<td align="right">835</td>
	<td align="right">2,301</td>
	<td align="right">(-13%)</td>
	<td align="right">2,652</td>
	<td align="right">4,641</td>
	<td align="right">(+75%)</td>
    </tr>
    <tr>
	<td>Log4J</td>
	<td align="right">44</td>
	<td align="right">542</td>
	<td align="right">3,331</td>
	<td align="right">10,880</td>
	<td align="right">(-16%)</td>
	<td align="right">12,961</td>
	<td align="right">27,215</td>
	<td align="right">(+110%)</td>
    </tr>
    <tr>
	<td>Xerces</td>
	<td align="right">51</td>
	<td align="right">880</td>
	<td align="right">11,218</td>
	<td align="right">38,194</td>
	<td align="right">(-13%)</td>
	<td align="right">43,893</td>
	<td align="right">80,472</td>
	<td align="right">(+83%)</td>
    </tr>
    <tr>
	<td>Xalan</td>
	<td align="right">58</td>
	<td align="right">855</td>
	<td align="right">10,763</td>
	<td align="right">35,317</td>
	<td align="right">(-15%)</td>
	<td align="right">41,594</td>
	<td align="right">81,745</td>
	<td align="right">(+97%)</td>
    </tr>
    </tbody>
    <tbody>
    <tr>
	<td>Ant</td>
	<td align="right">38</td>
	<td align="right">568</td>
	<td align="right">5,635</td>
	<td align="right">22,057</td>
	<td align="right">(-16%)</td>
	<td align="right">26,184</td>
	<td align="right">50,585</td>
	<td align="right">(+93%)</td>
    </tr>
    <tr>
	<td>Ant w/ optional</td>
	<td align="right">113</td>
	<td align="right">1,117</td>
	<td align="right">10,854</td>
	<td align="right">42,140</td>
	<td align="right">(-16%)</td>
	<td align="right">50,165</td>
	<td align="right">99,178</td>
	<td align="right">(+98%)</td>
    </tr>
    </tbody>
    <tbody>
    <tr>
	<td>Dependency Finder</td>
	<td align="right">27</td>
	<td align="right">364</td>
	<td align="right">3,587</td>
	<td align="right">13,098</td>
	<td align="right">(-18%)</td>
	<td align="right">15,897</td>
	<td align="right">28,923</td>
	<td align="right">(+82%)</td>
    </tr>
    </tbody>
</table>

---+++ Reporting

_Reporting_ means displaying a dependency graph.  More often than not, the
graph on display is a subset of a larger graph.  A graph is composed of nodes
and links.  When we display a subset of a graph, we must choose which nodes
and which links to include in the subset.  We use Perl regular expressions to
indicate what we are interested in.

So, reporting deals with selecting a subset of the dependency graph; that is,
choosing a subset of the nodes making up the graph and a subset of the links
to or from these nodes.  The _scope_ selects the nodes in the source graph
that will be copied into the destination graph.  We then _filter_ the links
(i.e., the dependencies) to or from nodes in the scope that will be copied
into the destination graph.  We must also copy the nodes at the other end of
these link if they were not already in the destination graph.

We use the term _scoping_ when talking about the selection process for nodes.
The GUI and the JSPs have a section labeled "Select programming elements" to
group the controls that govern scoping.

<div align="center">
    [[images/Scope.gif]]
*Scoping*
</div>

We use the term _filtering_ when talking about the selection process for
links.  The GUI and the JSPs have a section labeled "Show dependencies" to
group the controls that govern filtering.

<div align="center">
    [[images/Filter.gif]]
*Filtering*
</div>

Now both scoping and filtering have similar user interfaces.  I will talk
about the one for scoping here, but the filtering interface works the same
way.

First, a set of checkboxes narrow the search to only packages, classes,
features, or combinations thereof.  In the CLI, you achieve the same
effect through command-line switches.

<div align="center">
    [[images/ScopeControls.simple.highcontrols.jpg]]
</div>

    C:\>DependencyReporter -package-scope  \
                           -class-scope    \
                           -feature-scope

    C:\>DependencyReporter -all

    C:\>DependencyReporter -f2f

<div align="center">
*Scope Controls*
</div>

Secondly, you specify Perl regular expressions in an including and an
excluding text fields.  A node must match the regular expressions in the
including field and *not* match the ones in the excluding field.  You can
put multiple regular expressions in each field, separate them with commas
and they will be or'ed together.  On the command-line, just repeat the
switches.

<div align="center">
    [[images/ScopeControls.simple.highcriteria.jpg]]
</div>

    C:\>DependencyReporter -scope-includes //           \
                           -scope-excludes /Test/

<div align="center">
*Scope Criteria*
</div>

---++++ Perl Regular Expressions

The selective graph copier uses Perl regular expressions to select scope
nodes and filtered dependencies.

Here are links to pages explaining Perl regular expressions:

   * [[http://jakarta.apache.org/oro/api/org/apache/oro/text/regex/package-summary.html#package_description][Jakarta ORO]]
     (_what Dependency Finder is using_)
   * [[http://java.sun.com/j2se/1.4/docs/api/java/util/regex/Pattern.html#sum][JDK 1.4]]
   * [[http://www.perldoc.com/perl5.6/pod/perlre.html][Perldoc.com]]

Special characters in regular expressions:

<blockquote>
<table border="0"
       cellpadding="5">
    <tr>
	<td valign="top">
	    *=[A-Z]=*
	</td>
	<td>
	    Capitals
	</td>
    </tr>
    <tr>
	<td valign="top">
	    *=\w=*
	</td>
	<td>
	    Alphanumerics [A-Za-z0-9_]
	</td>
    </tr>
    <tr>
	<td valign="top">
	    *=\W=*
	</td>
	<td>
	    Non-alphanumerics [^A-Za-z0-9_]
	</td>
    </tr>
    <tr>
	<td valign="top">
	    *=\w+=*
	</td>
	<td>
	    At least one alphanumeric
	</td>
    </tr>
    <tr>
	<td valign="top">
	    *=\s=*
	</td>
	<td>
	    Space, including tab, carriage return, and line feed
	</td>
    </tr>
     <tr>
	<td valign="top">
	    *=\s%2A=*
	</td>
	<td>
	    Zero or more white space
	</td>
    </tr>
   <tr>
	<td valign="top">
	    *=\.=*
	</td>
	<td>
	    Matches '.', as opposed to any character
	</td>
    </tr>
</table>
</blockquote>

Sample rules:

<blockquote>
<table border="0"
       cellpadding="5">
    <tr>
	<td valign="top">
	    *=//=*
	</td>
	<td>
	    Matches everything.
	</td>
    </tr>
    <tr>
	<td valign="top">
	    *=/abc/=*
	</td>
	<td>
	    Matches anything with "=abc=" in it.  Case-sensitive.
	</td>
    </tr>
    <tr>
	<td valign="top">
	    *=/abc/i=*
	</td>
	<td>
	    Matches anything with "=abc=" in it.  Case-insensitive.
	</td>
    </tr>
    <tr>
	<td valign="top">
	    *=/^abc/=*
	</td>
	<td>
	    Matches anything starting with "=abc=" in it.
	</td>
    </tr>
    <tr>
	<td valign="top">
	    *=/abc\(/=*
	</td>
	<td>
	    Matches anything with "=abc(=" in it.  Parentheses are
	    special characters in Perl regular expressions and must be
	    escaped with a backslash "\" character.
	</td>
    </tr>
</table>
</blockquote>

Examples:

<blockquote>
<table border="0"
       cellpadding="5">
    <tr>
	<td valign="top">
	    *=/java/=*
	</td>
	<td>
	    Matches anything with "=java=" in it.
	</td>
    </tr>
    <tr>
	<td valign="top">
	    *=/^java/=*
	</td>
	<td>
	    Matches anything that starts with "=java=".
	</td>
    </tr>
     <tr>
	<td valign="top">
	    *=/^com.jeantessier/=*
	</td>
	<td>
	    Matches anything that starts with "=com.jeantessier=".  Here,
	    the '.' really matches any single character, which obviously
	    includes the '.' character itself.
	</td>
    </tr>
   <tr>
	<td valign="top">
	    *=/Node.Accept\(/=*
	</td>
	<td>
	    Matches any =Accept()= method of any class ending in "=Node=".
	</td>
    </tr>
    <tr>
	<td valign="top">
	    *=/Test/=*
	</td>
	<td>
	    Matches anything with "=Test=" in it.
	</td>
    </tr>
    <tr>
	<td valign="top">
	    *=/(Node)\.\1\(/=*
	</td>
	<td>
	    Matches any constructor for =Node=.
	</td>
    </tr>
    <tr>
	<td valign="top" nowrap>
	    *=/(\w%2AMeasurement)\.\1\(/=*
	</td>
	<td>
	    Matches any constructor for classes ending in =Measurement=.
	</td>
    </tr>
</table>
</blockquote>

---++++ Advanced View

So far, we have seen an interface where the Perl regular expressions apply
to all software artifacts, regardless of whether they are packages, classes,
or features.  Dependency Finder has a more elaborate interface, called the
advanced view, which allows you to specify regular expressions that apply
only to packages, or only to classes, or only to features.

<div align="center">
    [[images/ScopeControls.advanced.jpg]]
</div>

The checkboxes to select packages, classes, and features are arrayed on the
left of the user interface.  The text fields next to each one are for regular
expressions that will apply only to that type of programming element or
software artifact.  The top field in each column is from the simple view and
applies to all artifacts.

We achieve the same effect in the CLI by using multiple switches.  For
instance, =-feature-scope-includes= is for the "including" field in the
"Select programming elements" group that applies only to features.  It is
used in scoping feature nodes, if you use it along with =-feature-scope=.

E.g.,

    C:\>DependencyReporter -package-scope  \
                           -class-scope    \
                           -feature-scope

    C:\>DependencyReporter -all

    C:\>DependencyReporter -f2f

    C:\>DependencyReporter -scope-includes //

    C:\>DependencyReporter -scope-includes //                       \
                           -scope-excludes /Test/                   \
                           -feature-scope-includes /someMethod/     \
                           -feature-scope-includes /anotherMethod/

---++++ Showing Only Inbound Dependencies

Inbound dependencies show you who depends on a given programming element.
Is is very useful when assessing the impact of a change.  Dependency
Finder uses a textual notation to display them:

    programming element
        &lt;-- dependent 1
        &lt;-- dependent 2
            ...

When there are a lot of dependencies, either because the graph is very big
or an element is highly connected, it is useful to filter out the other
dependencies so that inbound ones stand out and are easier to read.

In =DependencyFinder= and the web application, there are three checkboxes
at the bottom of the control area.  They control how the graph is rendered.
To see only inbound dependencies, check the one labeled "inbounds" and
uncheck the one labeled "outbounds".  If a node has no inbound dependencies,
it will appear empty.  You can further filter them out by unchecking the
last checkbox, the one labeled "empty nodes", if you want.

If you are using the command-line tools, what you have is most likely a
graph rendered in XML, either from =DependencyExtractor= or
=DependencyReporter=.  You can use XML stylesheets to convert the XML to
something more user-friendly.  Dependency Finder provides two sample
stylesheets to show only inbound dependencies.  You can apply them with
the following tools:

    * =ListDependablesToText=
    * =ListDependablesToHTML=

E.g.,

    C:\>ListDependablesToText -in test.xml
    
        test
            test.main(java.lang.String[])
            test.test()
    java.lang
        java.lang.Object
            <-- test
            <-- test.main(java.lang.String[])
            java.lang.Object.Object()
                <-- test.main(java.lang.String[])
                <-- test.test()
        java.lang.String
            <-- test.main(java.lang.String[])
    java.util
        java.util.Collections
            java.util.Collections.singleton(java.lang.Object)
                <-- test.main(java.lang.String[])
        java.util.Set
            <-- test.main(java.lang.String[])

The HTML is weaved HTML cross-references between all the elements for easy
navigation.

You can list only non-empty nodes with:

    * =DependablesToText=
    * =DependablesToHTML=

E.g.,

    C:\>DependablesToText -in test.xml
    java.lang
        java.lang.Object
            <-- test
            <-- test.main(java.lang.String[])
            java.lang.Object.Object()
                <-- test.main(java.lang.String[])
                <-- test.test()
        java.lang.String
            <-- test.main(java.lang.String[])
    java.util
        java.util.Collections
            java.util.Collections.singleton(java.lang.Object)
                <-- test.main(java.lang.String[])
        java.util.Set
            <-- test.main(java.lang.String[])

---++++ Showing Only Outbound Dependencies

Outbound dependencies show you who a given programming element depends upon.
Is is very useful when partitioning programming elements and figuring out
what other classes a given class needs in order to run.  Dependency Finder
uses a textual notation to display them:

    programming element
        --&gt; dependable 1
        --&gt; dependable 2
            ...

When there are a lot of dependencies, either because the graph is very big
or an element is highly connected, it is useful to filter out the other
dependencies so that outbound ones stand out and are easier to read.

In =DependencyFinder= and the web application, there are three checkboxes
at the bottom of the control area.  They control how the graph is rendered.
To see only outbound dependencies, check the one labeled "outbounds" and
uncheck the one labeled "inbounds".  If a node has no outbound dependencies,
it will appear empty.  You can further filter them out by unchecking the
last checkbox, the one labeled "empty nodes", if you want.

If you are using the command-line tools, what you have is most likely a
graph rendered in XML, either from =DependencyExtractor= or
=DependencyReporter=.  You can use XML stylesheets to convert the XML to
something more user-friendly.  Dependency Finder provides two sample
stylesheets to show only outbound dependencies.  You can apply them with
the following tools:

    * =ListDependentsToText=
    * =ListDependentsToHTML=

E.g.,

    C:\>ListDependentsToText -in test.xml
    
        test
            --> java.lang.Object
            test.main(java.lang.String[])
                --> java.lang.Object
                --> java.lang.Object.Object()
                --> java.lang.String
                --> java.util.Collections.singleton(java.lang.Object)
                --> java.util.Set
            test.test()
                --> java.lang.Object.Object()
    java.lang
        java.lang.Object
            java.lang.Object.Object()
        java.lang.String
    java.util
        java.util.Collections
            java.util.Collections.singleton(java.lang.Object)
        java.util.Set

The HTML is weaved HTML cross-references between all the elements for easy
navigation.

You can list only non-empty nodes with:

    * =DependentsToText=
    * =DependentsToHTML=

E.g.,

    C:\>DependentsToText -in test.xml
    
        test
            --> java.lang.Object
            test.main(java.lang.String[])
                --> java.lang.Object
                --> java.lang.Object.Object()
                --> java.lang.String
                --> java.util.Collections.singleton(java.lang.Object)
                --> java.util.Set
            test.test()
                --> java.lang.Object.Object()

---++++ Showing Both Inbounds And Outbound Dependencies

You can combine the two approaches we just looked at and display the full
graph.  For the sake of brevity, when a node A depends on a node B and
that node B also depends on node A, Dependency Finder writes it as:

<pre>
    A
        &lt;-&gt; B
    B
        &lt;-&gt; A
</pre>

If you are using the command-line tools, what you have is most likely a
graph rendered in XML, either from =DependencyExtractor= or
=DependencyReporter=.  You can use XML stylesheets to convert the XML to
something more user-friendly.  Dependency Finder provides two sample
stylesheets to show all dependencies.  You can apply them with the
following tools:

    * =DependenciesToText=
    * =DependenciesToHTML=

The HTML is weaved HTML cross-references between all the elements for easy
navigation.

E.g.,

    C:\>DependenciesToText -in test.xml
    
        test
            --> java.lang.Object
            test.main(java.lang.String[])
                --> java.lang.Object
                --> java.lang.Object.Object()
                --> java.lang.String
                --> java.util.Collections.singleton(java.lang.Object)
                --> java.util.Set
            test.test()
                --> java.lang.Object.Object()
    java.lang
        java.lang.Object
            <-- test
            <-- test.main(java.lang.String[])
            java.lang.Object.Object()
                <-- test.main(java.lang.String[])
                <-- test.test()
        java.lang.String
            <-- test.main(java.lang.String[])
    java.util
        java.util.Collections
            java.util.Collections.singleton(java.lang.Object)
                <-- test.main(java.lang.String[])
        java.util.Set
            <-- test.main(java.lang.String[])

---+++ Transitive Closure

Dependencies are not automatically transitive, it depends on the
implementation details within the code.  Suppose you have:

    A --> B --> C

If you make a change in =C=, you may or may not have to modify =A=
depending on how =A= and =B= are implemented.

A transitive closure is the set of nodes that can be reached by
following downstream or upstream dependencies from a starting node.
The nodes in this set _might_ be impacted by a change, but they
are not automatically.  You get the _upstream closure_ by
following inbound dependencies.  You get the _downstream closure_
by following outbound dependencies.  Each string of dependencies
forms a _path_ through the graph between two nodes.  The number of
dependencies that form the path give the path's length.  The degree
of separation between two nodes is the length of the shortest path
between them.

Here is a further example:

    A --> B --> C --> D --> E

=C= is the starting point for the closure.  The set of nodes whose
distance to the source is 0 is =[C]=.  The set of nodes whose
distance to the source is 1 is =[B, D]=.  The set of nodes whose
distance to the source is 2 is =[A, E]=.

<blockquote>
<table cellpadding="3">
    <tr>
	<td>*distance*</td>
	<td></td>
	<td>*closure*</td>
    </tr>
    <tr>
	<td>0</td>
	<td></td>
	<td>=[C]=</td>
    </tr>
    <tr>
	<td>1</td>
	<td></td>
	<td>=[B, C, D]=</td>
    </tr>
    <tr>
	<td>_no constraint_</td>
	<td></td>
	<td>=[A, B, C, D, E]=</td>
    </tr>
    <tr>
	<td>_upstream_</td>
	<td></td>
	<td>=[A, B, C]=</td>
    </tr>
    <tr>
	<td>_downstream_</td>
	<td></td>
	<td>=[C, D, E]=</td>
    </tr>
</table>
</blockquote>

Here is the general algorithm:

    1 Initial set is the source itself.
    1 At each iteration, add nodes that are directly reachable and not not already in the set.
    1 Do as many iterations as needed, or until you don't add anything anymore.

A transitive closure only keeps the shortest path between two nodes.

---+++ Dependency Metrics

This is a simple tally of how many dependencies there are in a graph.  It
can give you a rough idea of the complexity of a given codebase, but it is
not as powerful as the metrics computed by =OOMetrics=.

----

---++ OO Metrics

Object-oriented software metrics help assess the quality of a piece of
software.  You can use them to verify that your architecture evolves in the
right direction, from version to version.  You can also use them to spot
deviations from your quality guidelines, such as methods that have too many
parameters or are too long.

Dependency Finder can use the information it extracts from class files to
compute software quality metrics.  Metrics measure certain aspects of
software and provide a quantitative assessment of its quality.

Dependency Finder recognizes four levels of metrics:

   * Project
   * Group
   * Class
   * Method

Each metrics is composed of a number of measurements.  What measurements
make up a given metrics level is defined in a configuration file written
in XML.

---+++ Explanation

A set of metrics is a group of measurements pertaining to a given _chunk_
of software.  Dependency Finder recognizes four sizes of _chunks_:

<blockquote>
<dl>
    <dt>Project</dt>
    <dd>These metrics apply to the project as a whole.</dd>
    <dt>Group</dt>
    <dd>These metrics apply to groups of classes.  A Java
    package is a _de facto_ group, but you can specify
    arbitrary groups using Perl regular expressions.</dd>
    <dt>Class</dt>
    <dd>These metrics apply to a single class.</dd>
    <dt>Method</dt>
    <dd>These metrics apply to individual methods within
    a class.</dd>
</dl>
</blockquote>

It does not track metrics about class attributes because these are not
really all that interesting.  The only measurements worth something deal
with dependencies, and I rolled those into class metrics.

The configuration file defines what measurements apply to which level of
scope (package, group, class, or method).  It also defines the rules for
creating arbitrary groups.  You can customize the content of your metrics
report by using different configuration files.

Each measurement has a name and a class that has the semantics of the
measurement.  There are classes for counters, lists, simple
mathematical expressions, etc.  Each measurement can be expressed as a
numeric value and the configuration file can defines the recommanded range
for that measurement.

The current types of measurement are as follow:

<blockquote>
<dl>
    <dt>=AccumulatorMeasurement=</dt>
    <dd>Aggregates lists in submetrics on the measurement's context.
    It uses Perl regular expressions to filter list elements.</dd>
    <dt>=CounterMeasurement=</dt>
    <dd>A simple counter, it tallies the values that are put in it.
    If you try to add a non-number, it simply adds 1.</dd>
    <dt>=NameListMeasurement=</dt>
    <dd>Accumulates a set of values.  Its numerical value is the
    cardinality (i.e., size) of the set.  =OOMetrics= uses it to
    keep track of dependencies.</dd>
    <dt>=NbSubMetricsMeasurement=</dt>
    <dd>Counts how many submetrics there are in the measurement's
    context.  It can use selection criteria while counting.  These
    are akin to "WHERE C > 10".</dd>
    <dt>=RatioMeasurement=</dt>
    <dd>Divides one measurement (base) by another (divider).  Both
    must be in the same context.</dd>
    <dt>=StatisticalMeasurement=</dt>
    <dd>Computes the statistical properties of a given measurement
    across the submetrics of the measurement's context.  Given a
    measurement name, it explores the tree of metrics rooted at the
    context and finds the numerical value of these named measurements
    in the tree.  For these measurements, it computes:
    <ul>
        <li>minimum value</li>
        <li>median value</li>
        <li>average value</li>
        <li>standard deviation</li>
        <li>maximum value</li>
        <li>sum</li>
        <li>number of data points</li>
    </ul></dd>
    <dt>=SumMeasurement=</dt>
    <dd>Adds up numerical values.  Use it with just one term to alias
    other measurements.</dd>
</dl>
</blockquote>

Whenever a measurement references another measurement, there is a chance
that that measurement is in fact a =StatisticalMeasurement= standing in
for a collection of others at the levels below.  The measurment making
the reference can specify explicitly which subvalue (i.e., minimum, median,
etc.) of the =StatisticalMeasurement= it wants to use for its own
computation.  Or, it can rely on the =StatisticalMeasurement='s self
disposition setting.  A =StatisticalMeasurement= can specify explicitly
which of its subvalues it wants to use for its numerical value.  By
default, this is the average value.

These measurements can potentially refer to other measurements and fall
under this disposition feature:

   * =NbSubMetricsMeasurement=
   * =RatioMeasurement=
   * =StatisticalMeasurement=
   * =SumMeasurement=

Right now, measurement processing is fixed.  In the future, you will be able
to define your own types of measurements and plug them into the framework.

=OOMetrics= and =OOMetricsGUI= create one project-level metrics for the
whole project.  This level has measurements that span the entire analyzed
codebase.  For each =.class= file, they create one class-level metrics for
that class, and one method-level metrics for each of its methods.

The tools add Class-level metrics to relevant group-level metrics.  One such
group, which the tools create automatically for each class, is named after
the package that this class belongs to.  You can define additional groups
in the configuration file by providing a name for the group and one or more
Perl regular expressions.  If the class name matches any of the regular
expressions, the class will be added to that group.  This allows you to
group together classes for a component or module that might span multiple
Java packages.

E.g.,

    &lt;group-definitions&gt;
        &lt;group-definition&gt;
            &lt;name&gt;Servlet API&lt;/name&gt;
            &lt;pattern&gt;/^javax.servlet/&lt;/pattern&gt;
        &lt;/group-definition&gt;
        &lt;group-definition&gt;
            &lt;name&gt;Test&lt;/name&gt;
            &lt;pattern&gt;/test/i&lt;/pattern&gt;
        &lt;/group-definition&gt;
    &lt;/group-definitions&gt;

---+++ Extracting

You use =OOMetrics= and =OOMetricsGUI= to extract =.class= files and
compute metrics.  The list of metrics is taken from a configuration file
written in XML.  You set the file with the =-configuration= switch to
either command.  There is also a =-default-configuration= switch that
kicks if you do not provide a =-configuration= switch.  This is how the
launching scripts can point to the standard configuration in
=%DEPENDENCYFINDER_HOME%/etc/MetricsConfig.xml= even if you don't
specify a configuration on the command-line.

There are two configurations that come bundled with Dependency Finder.

<blockquote>
<dl>
    <dt>=%DEPENDENCYFINDER_HOME%/etc/MetricsConfig.xml=</dt>
    <dd>It has a series of measurements and statistical compilations at
    various levels.  It can assist you in evaluating the size and
    complexity of your software.  You can use it to find large classes
    or methods, or to find pieces with a disproportionate number of
    dependencies.</dd>
    <dt>=%DEPENDENCYFINDER_HOME%/etc/MartinConfig.xml=</dt>
    <dd>Computes =I=, =A=, and =D'=, as per Robert C. Martin's
    article.</dd>
</dl>
</blockquote>

You can start from these to define your own configurations where you
adjust the output to the metrics you care about.

If you don't need a given measurement, put =visible%3D"no"= in its
=&lt;measurement&gt;= tag.  You could remove the tag altogether, but other
measurements might depend on it.  They would compute faulty values it
you were to remove it, whereas marking it invisible will only remove
it from the final output.

You can add new measurements that are functions of ones that already
exist.

<blockquote>
<dl>
    <dt>=AccumulatorMeasurement=</dt>
    <dd>For merging and filtering name lists</dd>
    <dt>=RatioMeasurement=</dt>
    <dd>For comparing values to one another</dd>
    <dt>=StatisticalMeasurement=</dt>
    <dd>Get distribution information for another measurement</dd>
    <dt>=SumMeasurement=</dt>
    <dd>Add measurments together or provide aliases to existing ones</dd>
</dl>
</blockquote>

Look at =%DEPENDENCYFINDER_HOME%/etc/MartinConfig.xml= for an exemple
of how you can combine these types of measurements to compute complex
values.

You can also add your own group definitions to report on related
classes that might not all be in the same Java package.  For example,
all classes with "Test" in the name, or all classes under a given
top-level package, such as =javax.servlet=.

You can customize the valid range of measurements to the particular
conditions of your project.  Each =&lt;measurement&gt;= tag can
contain optional =&lt;lower-threshold&gt;= and =&lt;upper-threshold&gt;=
tags.  Reports can highlight measurement values that fall outside
of the valid range you specified.

<blockquote>
<table cellpadding="5">
    <tr>
	<td>*specify*</td>
	<td></td>
	<td>*valid range is*</td>
    </tr>
    <tr>
	<td>none</td>
	<td></td>
	<td>all values are valid</td>
    </tr>
    <tr>
	<td>lower threshold only</td>
	<td></td>
	<td>all values greater than or equal to the threshold are valid</td>
    </tr>
    <tr>
	<td>upper threshold only</td>
	<td></td>
	<td>all values lesser than or equal to the threshold are valid</td>
    </tr>
    <tr>
	<td>both lower and upper threshold only</td>
	<td></td>
	<td>all values in the range between the lower and upper threshold,
	including them, are valid</td>
    </tr>
</table>
</blockquote>

Note that if all these ranges include the threshold themselves.  If a value
is equal to either the lower or the upper threshold, it is still considered
valid.  Also, if the upper threshold is less than the lower threshold, then
no value will ever be considered valid.  At this time, you cannot specify an
exlusive range, where a measurement would be valid unless it fell within the
designated range.

A future version of Dependency Finder will let you write custom measurement
classes so you can compute your own metrics.  Right now, the basic set is
hard-coded and the configuration allows you mainly to customize the report.

Statistical measurements can print out as:

    self%5Fdispose [minimum median/average standard%5Fdeviation maximum sum (size%5Fof%5Fdata%5Fset)]

The first value is the numeric value of the measurement.  Which one of the
values this is depends on the self disposition used in the measurement's
=&lt;init&gt;= tag.  By default, it is the average of the data set.

---++++ Extracting With the GUI

<div align="center">
    [[images/OOMetricsGUI.extract.high.jpg][images/s_OOMetricsGUI.extract.high.jpg]]
*Extract Dialog*
</div>

Select =File&nbsp;|&nbsp;Extract=; this will popup a file dialog.
Select the files and/or directories to extract from and click =Extract=.
You can repeat this command as often as needed; each time, the extracted
metrics will be added to the current set of metrics in memory.

You can limit the number of rows on display with the filtering mechanism at
the bottom of the user interface.  You enter a Perl regular expression in
the text field and click the button marked =Filter:=.

You can sort entries by the value of any measurement by clicking on the
header of each column.  Each mouse click alternates between ascending
and descending sorting order.  This also works for the =name= column.

---++++ Extracting With the CLI

You use =OOMetrics= to compute metrics and produce a report.  Simply string
out the files and directories on the command line.  The content of the report
depends on the switches on the command-line.

E.g.,

    C:\>OOMetrics -all -txt classes %JAVA_HOME%\JRE\lib\rt.jar

You must use at least one of the following switches that determine which
groups of metrics are included in the report.  You can combine them if
you need to.

<blockquote>
<dl>
    <dt>=-project=</dt>
    <dd>Include project-related metrics</dd>
    <dt>=-groups=</dt>
    <dd>Include group- and package-related metrics</dd>
    <dt>=-classes=</dt>
    <dd>Include class-related metrics</dd>
    <dt>=-methods=</dt>
    <dd>Include method-related metrics</dd>
    <dt>=-all=</dt>
    <dd>All of the above</dd>
</dl>
</blockquote>

You must also specify an output mode with one of these switches.

<blockquote>
<dl>
    <dt>=-csv=</dt>
    <dd>Writes each section in its own CSV file, perfect for loading in
    Microsoft Excel and charting</dd>
    <dt>=-txt=</dt>
    <dd>Writes a single text report with all requested sections</dd>
    <dt>=-xml=</dt>
    <dd>Writes a single XML report with all requested sections</dd>
</dl>
</blockquote>

You can specify an output file with the =-out= switch.  But in this case,
the switch only provides a prefix for the output files.  =OOMetrics= will
add the appropriate suffix, depending on the output mode.  For text and
XML output, it writes only one file with the total report.  For CSV output,
however, it writes one file per selected section; each filename starts
with the prefix you specify, followed by either "=%5Fproject=",
"=%5Fgroups=", "=%5Fclasses=", or "=%5Fmethods=" according to the section,
and ends with the "=.csv=" suffix.

    C:\>OOMetrics -all -txt %DEPENDENCYFINDER_HOME%\lib\DependencyFinder.jar -out df

----

---++ API Differences

If you are developing libraries or frameworks, that is, software that will
be used and/or extended by others, you need to know what changed from
version to version.  Your clients depend on your published set of APIs for
their own development efforts.  It becomes important, as you release new
revisions of your software, to keep track of which parts of the published
API changed, so that you can tell your clients how to upgrade their code.
The =JarJarDiff= tool can compute differences automatically, so you can
quickly know what you might have broken in your customer's code.

Even if this is not your case, it is still a good practive to have a
look at what changed across your software since the latest baseline.
This allows you to keep track of changes to the classes and methods
and verify that they are evolving in the right direction, whichever
way you decide that is.

---+++ Extracting

You use =JarJarDiff= to extract API differences.  The following command
computes the API differences between versions _Old_ and _New_ of
_My Project_.  The differences are saved as an XML document in the file
=diff.xml=.

    C:\>JarJarDiff -name "My Project"    \
                   -old-label Old        \
                   -old old.jar          \
                   -new-label New        \
	           -new new.jar          \
	           -out diff.xml

<div align="center">
    [[images/ExtractingDifferences.gif]]
*Extracting Differences*
</div>

You use =-old= switches to tell it where the _old_, or base version is
located.  Each =-old= switch can point to either a JAR file, a Zip file,
or a directory that will be searched for =.class= files.  You can
specify a label for the version with the =-old-label= switch.  If you
do not provide a label, the tool with create one by concatenating the
parameters to =-old= switches.

You use =-new= switches to tell it where the _new_, or modified version
is located.  Each =-new= switch can point to either a JAR file, a Zip
file, or a directory that will be searched for =.class= files.  You can
specify a label for the version with the =-new-label= switch.  If you
do not provide a label, the tool with create one by concatenating the
parameters to =-new= switches.

By default, the raw results are written in XML to the standard output
stream (i.e., =System.out=).  You can write it to a file by using the
=-out= switch.

---+++ Reporting

Dependency Finder includes XSL stylesheets for representing differences
using HTML.  The stylesheets include:

    * DiffToHTML.xsl
    * PublishedDiffToHTML.xsl
    * ListDocumentationDiffToText.xsl
    * ListDocumentationDiffToHTML.xsl
    * ListInheritanceDiffToText.xsl

You can run them using the script of the same name and the =-in= and
=-out= switches.  The scripts call =XSLTProcess= and specify the XSL
stylesheet with the =-xsl= switch.  You can do the same, if you want,
with either our stylesheets or your own.

---++++ Full List

You use =DiffToHTML= to convert all API differences to HTML.  The
following command produces a full report from the output of the previous
=JarJarDiff= command.

    C:\>DiffToHTML -in diff.xml          \
                   -out fullreport.html

<div align="center">
    [[images/CompleteList.gif]]
*Full List*
</div>

---++++ Public List

You use =PublishedDiffToHTML= to convert only public API differences
to HTML.  The following command produces a full report from the output
of the previous =JarJarDiff= command.

    C:\>PublishedDiffToHTML -in diff.xml                  \
                            -out publishedAPIreport.html

<div align="center">
    [[images/PublicList.gif]]
*Public List*
</div>

---++++ Filtering

You can also limit the reporting to specific programming elements that have
been earmarked using special javadoc tags.

You get the list of earmarked elements by running a specialized doclet.

The following commands run this doclet on the old as well as the new
codebases, saving the results in individual text files.

In this first case, the command will only list elements that you marked as
=@level published=.

    C:\>ListDocumentedElements -tag level         \
                               -valid published   \
                               -out old-list.txt  \
                               old.java

    C:\>ListDocumentedElements -tag level         \
                               -valid published   \
                               -out new-list.txt  \
                               new.java

If you add Dependency Finder's JAR file to your =CLASSPATH=, you can call
=javadoc= directly instead:

    C:\javadoc -doclet com.jeantessier.diff.ListDocumentedElements  \
               -tag level                                           \
               -valid published                                     \
               -out old-list.txt                                    \
               old.java

    C:\javadoc -doclet com.jeantessier.diff.ListDocumentedElements  \
               -tag level                                           \
               -valid published                                     \
               -out new-list.txt                                    \
               new.java

Or, as an Ant task:

    &lt;target name%3D"listdocumentedelements" depends%3D"init"&gt;
        &lt;javadoc packagenames%3D"${packageNames}"&gt;
	    &lt;sourcepath path%3D"src"/&gt;
	    &lt;classpath refid%3D"libs"/&gt;
	    &lt;doclet name%3D"com.jeantessier.diff.ListDocumentedElements"
		    path%3D"${classesDir}"&gt;
		&lt;param name%3D"-tag" value%3D"level"/&gt;
		&lt;param name%3D"-invalid" value%3D"developer"/&gt;
		&lt;param name%3D"-out" value%3D"df.txt"/&gt;
	    &lt;/doclet&gt;
	&lt;/javadoc&gt;
    &lt;/target&gt;

In this second case, the command will only list elements that you did marked
not mark as =@level developer=.

    C:\>ListDocumentedElements -tag level          \
                               -invalid published  \
                               -out old-list.txt   \
                               old.java

    C:\>ListDocumentedElements -tag level          \
                               -invalid developer  \
                               -out new-list.txt   \
                               new.java

<div align="center">
    [[images/ListDocumentedElements.gif]]
*Extracting Documented Elements*
</div>

You then feed the output from the doclet to =JarJarDiff=.

    C:\>JarJarDiff -name "My Project"               \
                   -old-label Old                   \
                   -old old.jar                     \
	           -old-documentation old-list.txt  \
                   -new-label New                   \
	           -new new.jar                     \
	           -new-documentation new-list.txt  \
	           -out diff.xml

<div align="center">
    [[images/ExtractingDifferencesAndDocumentationChanges.gif]]
*Extracting Differences on Documented Elements*
</div>

The full list will include special sections that highlight
changes in what is no more part of the documentation and what
was newly added to the documentation.

    C:\>DiffToHTML -in diff.xml          \
                   -out fullreport.html

<div align="center">
    [[images/CompleteListOfDocumentedElements.gif]]
*Full List Of Documented Elements*
</div>

The list can also be fed to =DiffToExternalHTML= to further
limit the changes to the published public API.

    C:\>PublishedDiffToHTML -in diff.xml                         \
                            -param validation-list new-list.txt  \
                            -out publishedAPIreport.html

<div align="center">
    [[images/PublicListOfDocumentedElements.gif]]
*Public List Of Documented Elements*
</div>

---++++ Listing Published Documentation Changes

You use =ListDiff= to list changes in what is considered part of the
published API.  It only needs the lists generated by the doclet.  No
source or bytecode required.

    C:\>ListDiff -name "My Project"  \
                 -old-label Old      \
                 -old old-list.txt   \
                 -new-label New      \
                 -new new-list.txt   \
                 -compress           \
                 -out listdiff.xml

<div align="center">
    [[images/ListDiff.gif]]
*Listing Differences in Documented Elements*
</div>

=ListDiff= writes in XML and you can convert this XML
into HTML with =ListDiffToHTML=, or to text with
=ListDiffToText=.

    C:\>ListDiffToHTML -in listdiff.xml     \
                       -out docreport.html

<div align="center">
    [[images/ListDiff2HTML.gif]]
*Report on Differences in Documented Elements*
</div>

<dl>
    <dt>NOTE:</dt>
    <dd><i>You can also use =ListDocumentationDiffToText=
    and =ListDocumentationDiffToHTML= to extract similar
    information from the output of JarJarDiff.  The list
    is written in HTML.  But we recommend that you use
    =ListDiff= instead; it is faster and simpler.</i></dd>
</dl>

----

---++ Support

Look at the current bug list on
[[http://sourceforge.net/projects/depfind][SourceForge]].  There is also
a help-oriented discussion forum.

You can also email me at
[[mailto://jeantessier@users.sourceforge.net][jeantessier at users.sourceforge.net]].

----
