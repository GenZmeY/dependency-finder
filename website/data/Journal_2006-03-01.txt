Tied =Instruction= more closely to =Code_attribute= so that some of the
instruction processing could be centralized there.  =Instruction= is now a
=Visitable= and =VisitorBase= automatically traverses them when processing a
=Code_attribute=.  So I was able to pull the code for iterating over bytecode
from the various visitors into the abstract base class.  Also, now that
individual =Instruction= instances know about their corresponding
=Code_attribute= and its =Classfile= and its =ConstantPool=, those that
represent opcodes with indices into the constant pool can retrieve the correct
=ConstantPoolEntry= themselves, instead of relying on client code to do it.
These two changes together simplified greatly the various operations that walk
the bytecode.

=Instruction= knows whether or not it holds an index into the constant pool.
For now, I simply used the list from =CodeDependencyCollector=, but I will need
to take a close look at the entire instruction set to make sure I have a
complete solution.

I also take this knowledge into account when comparing instructions in
=Instruction.equals()= and in computing =Instruction.hashCode()=.  If the
instruction actually refers to a =ConstantPoolEntry=, =equals()= and
=hashCode()= will use the entry's =equals()= and =hashCode()= as part of their
computation.  Otherwise, they just do a byte-to-byte comparision of the
instruction's data.
