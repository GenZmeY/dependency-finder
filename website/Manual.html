<!doctype html PUBLIC "-//W3C//DTD HTML 4.01//EN">

<html>

<head>
<link rel="stylesheet" type="text/css" href="style.css" />
</head>

<body>

<h1>The Dependency Finder Manual</h1>

<p>
by Jean Tessier
</p>

<hr />

<h2>Table of Contents</h2>
<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Installation">Installation</a></li>
<ul>
<li><a href="#JavaApplication">Java Application</a></li>
<ul>
<li><a href="#Step1:JavaVirtualMachine">Step 1: Java Virtual Machine</a></li>
<li><a href="#Step2:ExtractDependencyFinder">Step 2: Extract Dependency Finder</a></li>
<li><a href="#Step3:EnvironmentVariables">Step 3: Environment Variables</a></li>
<li><a href="#Step4:PATH">Step 4: <code>PATH</code></a></li>
<li><a href="#Step5:Reboot">Step 5: Reboot</a></li>
<li><a href="#Miscellaneous">Miscellaneous</a></li>
</ul>
<li><a href="#WebApplication">Web Application</a></li>
<ul>
<li><a href="#Step1:DeployWARFile">Step 1: Deploy WAR File</a></li>
<li><a href="#Step2:Configureweb.xmlfile">Step 2: Configure <code>web.xml</code> file</a></li>
</ul>
</ul>
<li><a href="#HistoryBehindDependencyFinder">History Behind Dependency Finder</a></li>
<ul>
<li><a href="#ClassFiles">Class Files</a></li>
<li><a href="#Dependencies">Dependencies</a></li>
<li><a href="#Metrics">Metrics</a></li>
<li><a href="#APIDifferences">API Differences</a></li>
</ul>
<li><a href="#RunningDependencyFinder">Running Dependency Finder</a></li>
<ul>
<li><a href="#GUI">GUI</a></li>
<li><a href="#CLI">CLI</a></li>
</ul>
<li><a href="#ClassFilesX">Class Files</a></li>
<ul>
<li><a href="#MetricsX">Metrics</a></li>
<li><a href="#Tools">Tools</a></li>
</ul>
<li><a href="#DependenciesX">Dependencies</a></li>
<ul>
<li><a href="#Extracting">Extracting</a></li>
<ul>
<li><a href="#ExtractingwiththeGUI">Extracting with the GUI</a></li>
<li><a href="#ExtractingwiththeCLI">Extracting with the CLI</a></li>
<li><a href="#MinimizingandMaximizing">Minimizing and Maximizing</a></li>
</ul>
<li><a href="#Reporting">Reporting</a></li>
<ul>
<li><a href="#PerlRegularExpressions">Perl Regular Expressions</a></li>
<li><a href="#TextualOutput">Textual Output</a></li>
<li><a href="#HTMLOutput">HTML Output</a></li>
</ul>
<li><a href="#TransitiveClosure">Transitive Closure</a></li>
<li><a href="#DependencyMetrics">Dependency Metrics</a></li>
</ul>
<li><a href="#OOMetrics">OO Metrics</a></li>
<ul>
<li><a href="#Explanation">Explanation</a></li>
<li><a href="#ExtractingX">Extracting</a></li>
<li><a href="#ReportingX">Reporting</a></li>
<ul>
<li><a href="#TextualOutputX">Textual Output</a></li>
<li><a href="#HTMLOutputX">HTML Output</a></li>
</ul>
</ul>
<li><a href="#APIDifferencesX">API Differences</a></li>
<ul>
<li><a href="#ExplanationX">Explanation</a></li>
<li><a href="#ExtractingXX">Extracting</a></li>
<li><a href="#ReportingXX">Reporting</a></li>
<ul>
<li><a href="#FullList">Full List</a></li>
<li><a href="#PublicList">Public List</a></li>
<li><a href="#Filtering">Filtering</a></li>
<li><a href="#ListingPublishedDocumentationChanges">Listing Published Documentation Changes</a></li>
</ul>
</ul>
<li><a href="#BuildingDependencyFinder">Building Dependency Finder</a></li>
<ul>
<li><a href="#CompilingaBuild">Compiling a Build</a></li>
<li><a href="#TestingtheBuild">Testing the Build</a></li>
</ul>
<li><a href="#Support">Support</a></li>
</ul>


<hr />

<a name="Introduction" />
<h2>Introduction</h2>

<p>
This application extracts information from compiled Java code and makes
it available to users in a numbers of ways.
</p>

<p>
Many authors have stressed the importance of managing depencencies
(<a href="http://www.objectmentor.com/resources/listArticles?key=author&author=Robert%20C.%20Martin">Robert C. Martin</a>,
<a href="http://www.amazon.com/exec/obidos/ASIN/0201633620/o/qid=980962318/sr=8-1/ref=aps_sr_b_1_1/105-0176284-9920776">John Lakos</a>).
Managing
dependencies means securing encapsulation and making sure that the code
follows the architecture.  It is also essential for the modularization
of code and favors reuse.  By extracting the information from the code
itself, we can detect where we were sloppy, where we took shortcuts that
we shouldn't have.  Managing the dependencies can shorten the compilation
time of the code.
</p>

<p>
This application also includes tools for computing metrics based on
information extracted from compiled Java code.  These measurements are
also helpful guides during development and can point out areas in the
code that need improvement.
</p>

<p>
Finally, this application includes a tool that computes the changes in
the API of a system between successive versions.  You can use it as a
consumer of libraries to verify that the parts you are dependending
upon have not changed.  You can use it as a producer of libraries to
assertain the impact your changes might have on your customers.  You
can even use it to monitor the evolution of your software.
</p>

<hr />

<a name="Installation" />
<h2>Installation</h2>

<a name="JavaApplication" />
<h3>Java Application</h3>

<p>
Dependency Finder comes as a ZIP file that includes everything you need
to run it.
</p>

<a name="Step1:JavaVirtualMachine" />
<h4>Step 1: Java Virtual Machine</h4>

<p>
You need to have a Java Virtual Machine installed.  You can get one for
free from <a href="http://www.javasoft.com/">JavaSoft</a>.  Make sure you define
the <code>JAVA_HOME</code> environment variable.
</p>

<p>
For example, if you installed JDK 1.3 in <code>C:\jdk1.3</code>:
</p>

<pre>
    SET JAVA_HOME=C:\jdk1.3
</pre>

<p>
You can either add this line to your <code>AUTOEXEC.BAT</code> file, or on WinNT
use Start | Settings | Control Panel | System and select the Environment
tab to create and edit variables.
</p>

<a name="Step2:ExtractDependencyFinder" />
<h4>Step 2: Extract Dependency Finder</h4>

<p>
Extract the ZIP file to some directory you like.  The extraction will
create a subdirectory named "DependnecyFinder" that is the root of the
package.
</p>

<p>
For example, if you extract it to <code>C:\</code>, you will endup with a
directory called <code>C:\DependencyFinder\</code>.
</p>

<a name="Step3:EnvironmentVariables" />
<h4>Step 3: Environment Variables</h4>

<p>
Create an environment variable named <code>DEPENDENCYFINDER_HOME</code> and have it
point to the directory where you installed Dependency Finder.
</p>

<p>
For example, if you extracted the ZIP file in <code>C:\</code>
</p>

<pre>
    SET DEPENDENCYFINDER_HOME=C:\DependencyFinder
</pre>

<p>
You can either enter this line in your <code>AUTOEXEC.BAT</code> file, or on WinNT
use Start | Settings | Control Panel | System and select the Environment
tab to create and edit variables.
</p>

<i>This is only required with Win95/98.  Under WinNT, the scripts are
smart enough to find out where you installed Dependency Finder on their
own.</i>

<a name="Step4:PATH" />
<h4>Step 4: <code>PATH</code></h4>

<p>
Add the "bin" subdirectory to your <code>PATH</code> variable.
</p>

<p>
For example, if you extracted the ZIP file in <code>C:\</code>
</p>

<pre>
    SET PATH=C:\DependencyFinder\bin;%PATH%
</pre>

<a name="Step5:Reboot" />
<h4>Step 5: Reboot</h4>

<p>
Under Win95/98, you will need to reboot your computer for the changes to
the environment to take effect.
</p>

<a name="Miscellaneous" />
<h4>Miscellaneous</h4>

<p>
If the VM runs out of memory, try setting the <code>DEPENDENCYFINDER_OPTS</code>
environment variable.
</p>

<pre>
    SET DEPENDENCYFINDER_OPTS=-Xmx128m
</pre>

<p>
If you get the message "Out of environment space" while running the
scripts on a Windows machine, you will need to add the following line
to your <code>C:\CONFIG.SYS</code> file and then reboot.
</p>

<pre>
    shell=command.com /e:8192 /p
</pre>

<a name="WebApplication" />
<h3>Web Application</h3>

<p>
Dependency Finder also comes as a web application that you can easily
deploy in just about any J2EE servlet container.
</p>

<a name="Step1:DeployWARFile" />
<h4>Step 1: Deploy WAR File</h4>

<p>
Use your favorite servlet container to deploy the WAR file.  For
instance, under Tomcat:
</p>

<pre>
    C:\>%CATALINA_HOME%\bin\shutdown
    C:\>COPY DependencyFinder.war %CATALINA_HOME%\webapps
    C:\>%CATALINA_HOME%\bin\startup
</pre>

<a name="Step2:Configureweb.xmlfile" />
<h4>Step 2: Configure <code>web.xml</code> file</h4>

<p>
Next, you need to tell the wep application where to find the Java
classes to extract dependencies from.  This is done via the <code>web.xml</code>
file in the <code>WEB-INF\</code> directory.  Some application servers expose
the content of this file through some form of user interface.  Under
Tomcat, you have to edit the file yourself using a text editor.
</p>

<p>
There are three application variable to adjust.
</p>

<blockquote>
<table border="0"
       cellpadding="5">
    <tr>
	<td valign="top">
	    <b><code>name</code></b>
	</td>
	<td>
	    Used in the JSPs to tell the users what that are looking
	    at.  Put the name of the application that you are
	    extracting from here.
	</td>
    </tr>
    <tr>
	<td valign="top">
	    <b><code>source</code></b>
	</td>
	<td>
	    Use this variable to tell Dependency Finder where to locate
	    classes to extract.  You can separate multiple locations
	    by using commas.  Each location can either be a JAR file,
	    a ZIP file, a <code>.class</code> file, or a directory that will be
	    recursively searched for <code>.class</code> files.
	</td>
    </tr>
    <tr>
	<td valign="top">
	    <b><code>mode</code></b>
	</td>
	<td>
	    Tells Dependency Finder whether to <i>minimize</i> or <i>maximize</i>
	    the resulting graph, or just leave it alone (<i>raw</i>, the
	    default value).
	</td>
    </tr>
</table>
</blockquote>

<p>
Under some servlet containers, for example Tomcat, you will need to
restart the servlet container for the changes to take effect.
</p>

<pre>
    C:\>%CATALINA_HOME%\bin\shutdown
    C:\>%CATALINA_HOME%\bin\startup
</pre>

<hr />

<a name="HistoryBehindDependencyFinder" />
<h2>History Behind Dependency Finder</h2>

<p>
This project started because another project of mine became so complex
that I couldn't track dependencies in my head anymore.  I looked for
a tool to help me and the only ones I could find were very expensive.
So I resolved to build my own tool.
</p>

<p>
I haven't touched that other project since.
</p>

<a name="ClassFiles" />
<h3>Class Files</h3>

<p>
At first, I thought of using the Reflection API, but it shows only the
class's attributes and method signatures.  If a method uses other classes
as part of its processing, that dependency will not show under the
Reflection API.
</p>

<p>
Java compilers take source code and produce bytecode that they put in
<code>.class</code> files.  The format of these files is described in
<a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html">The <code>class</code> File Format</a>.
I undertook to parse these files and extract the information I needed
directly from the compiled code.
</p>

<a name="Dependencies" />
<h3>Dependencies</h3>

<p>
Dependencies occur when one class uses the services of another class.
This can happen when a class inherits from another, has an attribute
whose type is of another class, or when one of its methods calls a
method on an object of another class.
</p>

<p>
Knowing about dependencies is useful for programmers when deciding the
impact of a change.  When you're about to rename a feature or class,
it is useful to know all the places in the codebase where it is being
used.
</p>

<p>
This is also useful for code reviewers and architects when assessing the
coupling within an application or library.
</p>

<a name="Metrics" />
<h3>Metrics</h3>

<p>
Object-oriented metrics help assess the quality of a piece of software.
You can use them to verify that your architecture evolves in the right
direction, from version to version.  You can also use them to spot
deviations from your quality guidelines, such as methods that are too
long or have too many parameters.
</p>

<a name="APIDifferences" />
<h3>API Differences</h3>

<p>
If you are developing some kind of library or framework, that is,
software that will be used and/or extended by others, you need to know
what changed from version to version.  The <code>JarJarDiff</code> tool can
compute differences automatically, so you can quickly know what you
might have broken in your customer's code.
</p>

<hr />

<a name="RunningDependencyFinder" />
<h2>Running Dependency Finder</h2>

<p>
Once you have installed Dependency Finder, you are ready to use all the
tools now at your disposal.  All of them are Java applications that you
launch using a batch file or shell script.
</p>

<p>
At the beginning, the toolset was just a group of batch files that
offered a basic command-line interface (CLI).  Later, I added a Swing
graphical interface (GUI) that simply replicated the controls available
through the CLI.  Finally, I build a web application that mirrored the
GUI.  This might help explain why the the interface looks the way it
does and why it may not always be optimally intuitive.
</p>

<p>
We will start with the GUI-based tools, and then talk about the CLI-based
tools.
</p>

<p>
All the tools support the following three command-line switches:
</p>

<blockquote>
<table border="0"
       cellpadding="5">
    <tr>
	<td valign="top"
	    nowrap="true">
	    <code>-help</code>
	</td>
	<td>
	    Prints the list of valid command-line switches for that
	    particular tool.
	</td>
    </tr>
    <tr>
	<td valign="top"
	    nowrap="true">
	    <code>-trace [filename]</code>
	</td>
	<td>
	    Writes <i>very</i> detailed processing information to <i>filename</i>.
	    If you do not specify a file, the tool will write the
	    information to the standard output stream.
	</td>
    </tr>
    <tr>
	<td valign="top"
	    nowrap="true">
	    <code>-verbose [filename]</code>
	</td>
	<td>
	    Writes summary processing information to <i>filename</i>.
	    If you do not specify a file, the tool will write the
	    information to the standard output stream.
	</td>
    </tr>
</table>
</blockquote>

<p>
Many of the tools also support some or all of the following three
command-line switches:
</p>

<blockquote>
<table border="0"
       cellpadding="5">
    <tr>
	<td valign="top"
	    nowrap="true">
	    <code>-in</code>
	</td>
	<td>
	    Many of the CLI tools are automated translation of XML data
	    into either HTML or plain text.  The scripts have hard-coded
	    XSL stylesheets.  You specify the XML input with this switch.
	</td>
    </tr>
    <tr>
	<td valign="top"
	    nowrap="true">
	    <code>-out filename</code>
	</td>
	<td>
	    Writes the output of the command to <i>filename</i>.  Most
	    commands default to the standard output if you do not
	    use <code>-out</code>.
	</td>
    </tr>
    <tr>
	<td valign="top"
	    nowrap="true">
	    <code>-time</code>
	</td>
	<td>
	    Prints the time it took to run the command.  If you run
	    commands against a large codebase or dependency graph,
	    it can take a substantial amount of time before it returns.
	    This information can help you plan lenghty operations in
	    the future.
	</td>
    </tr>
</table>
</blockquote>

<a name="GUI" />
<h3>GUI</h3>

<p>
The main tool is <code>DependencyFinder</code>.  It extracts dependencies from
compiled code, maintains the dependency graph in memory, and provides
an interface for querying the graph and display the results.
</p>

<div align="center">
    <a href="images/DependencyFinder.jpg"><img src="images/s_DependencyFinder.jpg" /></a><br />
<b>DependencyFinder</b>
</div>

<p>
The other tool computes metrics on a given codebase.  It displays
results in a table with sortable columns.  Different tabs control the
level of detail: package, class, or method.
</p>

<div align="center">
    <a href="images/OOMetricsGUI.jpg"><img src="images/s_OOMetricsGUI.jpg" /></a><br />
<b>OOMetricsGUI</b>
</div>

<a name="CLI" />
<h3>CLI</h3>

<div align="center">
    <img src="images/Flow.gif" /><br />
<b>Document Flow</b>
</div>

<hr />

<a name="ClassFilesX" />
<h2>Class Files</h2>

<p>
You use the <code>com.jeantessier.classreader</code> package to parse compiled
Java code.  You feed files to a <code>ClassfileLoader</code> and you get instances
of <code>Classfile</code> from it.
</p>

<p>
There are two kinds of <code>ClassfileLoader</code>.  The first kind opens input
streams from the data sources and passes these streams to an underlying
<code>ClassfileLoader</code> of the second kind.  The second kind creates the
<code>Classfile</code> instances and fires processing events to registered listeners.
The reason for the separation is because the first kind handles various
file types, while the second kind handles how long the <code>Classfile</code>
instances remain in memory.
</p>

<p>
The first kind derives from <code>ClassfileLoaderDecorator</code> and follows the
decorator pattern.  It wraps another <code>ClassfileLoader</code>, passing it input
streams and triggering event firing.  It includes the following concrete
classes:
</p>

<ul>
<li>DirectoryClassfileLoader</li>
<li>ZipClassfileLoader</li>
<li>JarClassfileLoader</li>
</ul>

<p>
The second kind derives from <code>ClassfileLoaderEventSource</code>.  These classes
create instances of <code>Classfile</code> and keep track of <code>LoadListener</code> objects.
It includes the following concrete classes:
</p>

<ul>
<li>AggregatingClassfileLoader</li>
<li>TransientClassfileLoader</li>
</ul>

<p>
Once you have an instance of <code>Classfile</code>, you can traverse it with a
class that implements <code>com.jeantessier.classreader.Visitor</code>.  It has
callback methods that get called by the various components of the
<code>Classfile</code>.
</p>

<a name="MetricsX" />
<h3>Metrics</h3>
<a name="Tools" />
<h3>Tools</h3>

<ul>
<li>ClassReader</li>
<li>ClassDump</li>
<li>ClassInheritance</li>
<li>ClassMetrics</li>
<li>ClassList</li>
</ul>

<hr />

<a name="DependenciesX" />
<h2>Dependencies</h2>

<p>
Dependency Finder builds dependency graphs based on the information
in class files.
</p>

<p>
As we mentioned earlier, a dependency is when the functioning of one
element <code>A</code> requires the presence of another element <code>B</code>.  We say that
<code>A</code> <i>depends</i> on <code>B</code> and we write it:
</p>

<pre>
    A --> B
</pre>

<p>
We say that <code>A</code> has an <i>outbound</i> dependency while <code>B</code> has an
<i>inbound</i> dependency.  It is the same dependency, but whether it
is inbound or outbound is relative to how you look at it.  We also
say that <code>A</code> is a <i>dependent</i> and <code>B</code> is <i>dependable</i>.
</p>

<p>
A dependency graph comprises nodes for software artifacts linked
together by two types of relationships.  Artifacts are packages,
classes, and features.  We use the term <i>feature</i> to designate
class attributes, constructors, and methods; we will be treating
them the same from here on.  For the purpose of analyzing dependencies,
we do not distinguish between different types of features, whether they
are constructors or regular methods, and regardless of the feature's
characteristics, such as being marked as <code>final</code> or <code>static</code>.
</p>

<p>
Packages have classes, which themselves have features; this is called
<i>composition</i>.  Classes refer to each other and so do features; this is
called a <i>dependency</i>.
</p>

<p>
So a feature node is linked to its class node through composition.
The class node is also linked to its package node through
composition.  Each is linked to various other nodes of various type
using dependency links.
</p>

<a name="Extracting" />
<h3>Extracting</h3>

<p>
Going through class files and collecting dependencies is called
<i>extracting</i>.  The application keeps dependencies in a graph.  It
begins with one node per Java package.  To this it adds one node
per Java class (including inner classes), and to those it adds
one node per feature.
</p>

<p>
Dependency Finder can read all types of compiled Java: JAR files,
ZIP files, or class files.  You can point it to a JAR, ZIP, or
<code>.class</code> file.  You can also point it to a directory and it will
explore that directory and all its subdirectories for files ending
in <code>.class</code>.  You can select more than one target, mix and match
JARs and ZIPs and class files and directories, and Dependency
Finder will aggregate all their contents together.  It will sort
them all out.
</p>

<p>
The dependencies are gathered by the class
<code>com.jeantessier.dependency.CodeDependencyCollector</code>.  It traverses
the structure of a <code>.class</code> file, as read by
<code>com.jeantessier.classreader.Classfile</code>, and collects explicit
dependencies in the bytecode.
</p>

<p>
The dependency collector can detect three kinds of explicit
dependencies, from which Dependency Finder can infer all implicit
dependencies:
</p>

<ol>
<li>feature to feature</li>
<li>feature to class</li>
<li>class to class</li>
</ol>

<div align="center">
    <img src="images/ExplicitImplicit.gif" /><br />
<b>Explicit and Implicit Dependencies</b>
</div>

<p>
There are <i>explicit</i> dependencies, as present in the code itself.  There
are also <i>implicit</i> dependencies derived from these explicit ones.  A
dependency between two classes in two separate packages <i>implies</i> a
dependency between the packages.
</p>

<a name="ExtractingwiththeGUI" />
<h4>Extracting with the GUI</h4>

<div align="center">
    <a href="images/HighlightedExtractDialog.jpg"><img src="images/s_HighlightedExtractDialog.jpg" /></a><br />
<b>Extract Dialog</b>
</div>

<p>
Select <code>File&nbsp;|&nbsp;Extract</code>; this will popup a file dialog.
Select the files and/or directories to extract from and click <code>Extract</code>.
You can repeat this command as often as needed; each time, the extracted
dependencies will be added to the current dependency graph.
</p>

<a name="ExtractingwiththeCLI" />
<h4>Extracting with the CLI</h4>

<p>
You use <code>DependencyExtractor</code> to extract dependencies.  Simply string
out the files and directories on the command line.
</p>

<p>
E.g.,
</p>

<pre>
    C:\>DependencyExtractor classes %JAVA_HOME%\JRE\lib\rt.jar
</pre>

<p>
All the dependencies are merged into a single output.
</p>

<a name="MinimizingandMaximizing" />
<h4>Minimizing and Maximizing</h4>

<p>
We <i>minimize</i> the dependency graph when we remove redundant dependencies.
If method <code>a()</code> in class <code>A</code> calls method <code>b()</code> in class <code>B</code>, the
dependency <code>A.a()&nbsp;-->&nbsp;B.b()</code> implies the dependency
<code>A&nbsp;-->&nbsp;B</code>.  If the latter is also present in the code, let's
say because <code>A extends B</code>, then it becomes explicit and redundant, since
is was already introduced by the former dependency.  We can safely remove
the explicit reference to <code>A&nbsp;-->&nbsp;B</code> without any loss of
information.
</p>

<p>
We <i>maximize</i> the dependency graph when we expose all implicit
dependencies by making them explicit.  To take back our previous
example, <code>A.a()&nbsp;-->&nbsp;B.b()</code>, maximizing it will introduce
the following dependencies:
</p>

<ul>
<li><code>A.a()&nbsp;-->&nbsp;B</code></li>
<li><code>A&nbsp;-->&nbsp;B.b()</code></li>
<li><code>A&nbsp;-->&nbsp;B</code></li>
</ul>

<p>
Maximizing and minimizing the dependency graph deals with the trade off
between space and time.  Minimizing the graph saves on space, but it
takes longer to traverse the graph to find if there is a dependency
between two given nodes.  Maximizing the graph saves on time, since all
the dependencies are there for the picking, but the size of the graph
goes up dramatically.
</p>

<p>
The illustrations below show how combinations of these are minimized or
maximized.  You can minimize a graph that has been maximized and obtain
the same minimized graph as if you had minimized the original graph.
Similarily, if you maximize a graph that has been minimized, you end up
with the same graph as if you had minimized the original graph.
</p>

<div align="center">
    <img src="images/MinMaxTitle.gif" /><br />
    <img src="images/MinMaxI.gif" /><br />
    <img src="images/MinMaxII.gif" /><br />
    <img src="images/MinMaxIII.gif" /><br />
    <img src="images/MinMaxIV.gif" /><br />
    <img src="images/MinMaxV.gif" /><br />
    <img src="images/MinMaxVI.gif" /><br />
    <img src="images/MinMaxVII.gif" /><br />
    <img src="images/MinMaxVIII.gif" /><br />
</div>

<a name="Reporting" />
<h3>Reporting</h3>

<p>
<i>Reporting</i> is the act of displaying a dependency graph, or more often
a subset of it.  The graph is composed of nodes and links.  We apply
scoping to the nodes and filtering to the links.  In each case, we will
use Perl regular expressions to indicate which nodes and links we are
interested in.
</p>

<p>
So, reporting deals with selecting a subset of the dependency graph;
that is, choosing a subset of the nodes making up the graph and a
subset of the links to or from these nodes.  The <i>scope</i> selects the
nodes in the source graph that will be copied into the destination
graph.  The <i>filter</i> selects the links (i.e., the dependencies) to or
from scoped nodes that will be copied into the destination graph,
along with the nodes at the other end of these link if they were not
already in the destination graph.
</p>

<p>
We use the term <i>scoping</i> when talking about the selection process for
nodes.  We use the term <i>filtering</i> when talking about the selection
process for links.
</p>

<div align="center">
    <img src="images/Scope.gif" /><br />
<b>Scoping</b>
</div>

<div align="center">
    <img src="images/Filter.gif" /><br />
<b>Filtering</b>
</div>

<p>
Both scoping and filtering have their own selection process that
includes inclusion and exclusion criteria.  A given node is selected
if it meets any of the inclusion criteria for scoping and meets none
of the exclusion criteria for scoping.  Once a node is selected, we
look at the nodes at the other end of links into and out of that node;
the link is selected if the other node meets any of the inclusion
criteria for filtering and meets none of the exclusion criteria for
filtering.
</p>

<p>
From the start, you decide if each selection process applies to
packages, classes, and features.  In <code>DependencyFinder</code>, you do this
through checkboxes.  In <code>DependencyReporter</code>, you do it through
specific command line switches.  <code>DependencyReporter</code> also has
shortcuts that can replace multiple switches.
</p>

<p>
E.g.,
</p>

<pre>
    C:\>DependencyReporter -package-scope  \
                           -class-scope    \
                           -feature-scope
</pre>

<pre>
    C:\>DependencyReporter -all
</pre>

<pre>
    C:\>DependencyReporter -f2f
</pre>

<div align="center">
    <a href="images/HighlightedScopeControls.jpg"><img src="images/s_HighlightedScopeControls.jpg" /></a><br />
<b>Scope Controls GUI</b>
</div>

<p>
Each process has separate criteria for inclusion and exclusion.  They
work the same way, as far as matching nodes is concerned.  The
difference is only in how the process uses the outcome to decide
whether to keep a node or link or not.  For a node or link to be
selected, it must meet AT LEAST ONE of the relevant inclusion
criteria and NONE of the relevant exclusion criteria.
</p>

<p>
In each case, the criteria are a series of regular expressions applied
to a node's name.  Each series is composed of the union of two groups
out of four difference sets.  Which sets are selected depends on the
type of the node, whether it is a node for a package, class, or
feature.
</p>

<p>
The first set of regular expressions applies regardless of the type
of node.  You specify it with the top text field in the GUI.  This
is the only set that you can specify when using the simple form.  Of
the remaining three sets, one applies only to package nodes, one only
to class nodes, and the last one only to feature nodes.  The GUI
places each one on a row with the corresponding labels.
</p>

<p>
The following table summarizes which sets are relevant.  Each column
in the GUI follows these rules.  The columns of GUI elements match
scoping inclusion, scoping exclusion, filtering inclusion, and
filtering exclusion respectively.
</p>

<div align="center">
<table border="3"
       cellpadding="5">
    <caption align="bottom"><b>Relevant Selection Criteria</b></caption>
    <tr>
	<td />
	<td align="center">
	    <b>package</b><br />node or link
	</td>
	<td align="center">
	    <b>class</b><br />node or link
	</td>
	<td align="center">
	    <b>feature</b><br />node or link
	</td>
    </tr>
    <tr>
	<td align="center">
	</td>
	<td align="center">
	    X
	</td>
	<td align="center">
	    X
	</td>
	<td align="center">
	    X
	</td>
    </tr>
    <tr>
	<td>
	    package
	</td>
	<td align="center">
	    X
	</td>
	<td align="center">
	    &nbsp;
	</td>
	<td align="center">
	    &nbsp;
	</td>
    </tr>
    <tr>
	<td>
	    class
	</td>
	<td align="center">
	    &nbsp;
	</td>
	<td align="center">
	    X
	</td>
	<td align="center">
	    &nbsp;
	</td>
    </tr>
    <tr>
	<td>
	    feature
	</td>
	<td align="center">
	    &nbsp;
	</td>
	<td align="center">
	    &nbsp;
	</td>
	<td align="center">
	    X
	</td>
    </tr>
</table>
</div>

<p>
To repeat, each criterion is a set of Perl regular expressions.  For
scoping, the name of the node must match at least one of the regular
expressions for it to meet the criterion.  Filtering is always done
relative to a node that is in scope.  A link will be selected if the
name of the node at the other end of the link passes the filtering
selection process.
</p>

<p>
In <code>DependencyFinder</code>, you specify criteria through a number of text
areas.  In <code>DependencyReporter</code>, you do it with specific command line
switches.  You specify multiple regular expressions for a set by
using separating them with commas in the GUI or by using the same
command line switch multiple times.
</p>

<p>
E.g.,
</p>

<pre>
    C:\>DependencyReporter -scope-includes //
</pre>

<pre>
    C:\>DependencyReporter -scope-includes //                       \
                           -scope-excludes /Test/                   \
                           -feature-scope-includes /someMethod/     \
                           -feature-scope-includes /anotherMethod/
</pre>

<div align="center">
    <a href="images/HighlightedScopeCriteria.jpg"><img src="images/s_HighlightedScopeCriteria.jpg" /></a><br />
<b>Scope Criteria GUI</b>
</div>

<a name="PerlRegularExpressions" />
<h4>Perl Regular Expressions</h4>

<p>
The selective graph copier uses Perl regular expressions to select scope
nodes and filtered dependencies.
</p>

<p>
Here are links to pages explaining Perl regular expressions:
</p>

<ul>
<li><a href="http://jakarta.apache.org/oro/api/org/apache/oro/text/regex/package-summary.html#package_description">Jakarta ORO</a></li>
     (<i>what Dependency Finder is using</i>)
<li><a href="http://java.sun.com/j2se/1.4/docs/api/java/util/regex/Pattern.html#sum">JDK 1.4</a></li>
<li><a href="http://www.perldoc.com/perl5.6/pod/perlre.html">Perldoc.com</a></li>
</ul>

<p>
E.g.,
</p>

<blockquote>
<table border="0"
       cellpadding="5">
    <tr>
	<td valign="top">
	    <b><code>//</code></b>
	</td>
	<td>
	    Matches everything.
	</td>
    </tr>
    <tr>
	<td valign="top">
	    <b><code>/abc/</code></b>
	</td>
	<td>
	    Matches anything with "<code>abc</code>" in it.  Case-sensitive.
	</td>
    </tr>
    <tr>
	<td valign="top">
	    <b><code>/abc/i</code></b>
	</td>
	<td>
	    Matches anything with "<code>abc</code>" in it.  Case-insensitive.
	</td>
    </tr>
    <tr>
	<td valign="top">
	    <b><code>/^abc/</code></b>
	</td>
	<td>
	    Matches anything starting with "<code>abc</code>" in it.
	</td>
    </tr>
    <tr>
	<td valign="top">
	    <b><code>/abc\(/</code></b>
	</td>
	<td>
	    Matches anything with "<code>abc(</code>" in it.  Parentheses are
	    special characters in Perl regular expressions and must be
	    escaped with a backslash "\" character.
	</td>
    </tr>
</table>
</blockquote>

<a name="TextualOutput" />
<h4>Textual Output</h4>

<p>
Dependency Finder includes XSL stylesheets for representing a dependency
graph using simple text.  The stylesheets can either render the whole
graph or only show inbound or outbound dependencies.
</p>

<p>
The stylesheets include:
</p>

<ul>
<li>DependablesToText.xsl</li>
<li>DependenciesToText.xsl</li>
<li>DependentsToText.xsl</li>
<li>ListDependablesToText.xsl</li>
<li>ListDependentsToText.xsl</li>
</ul>

<p>
You can run them using the script of the same name and the <code>-in</code> and
<code>-out</code> switches.  The scripts call <code>XSLTProcess</code> and specify the XSL
stylesheet with the <code>-xsl</code> switch.  You can do the same, if you want,
with either our stylesheets or your own.
</p>

<a name="HTMLOutput" />
<h4>HTML Output</h4>

<p>
Dependency Finder includes XSL stylesheets for representing a dependency
graph using HTML.  The stylesheets can either render the whole graph or
only show inbound or outbound dependencies.  Dependency Finder renders
dependencies as hyperlinks to the appropriate node.
</p>

<p>
The stylesheets include:
</p>

<ul>
<li>DependablesToHTML.xsl</li>
<li>DependenciesToHTML.xsl</li>
<li>DependentsToHTML.xsl</li>
<li>ListDependablesToHTML.xsl</li>
<li>ListDependentsToHTML.xsl</li>
</ul>

<p>
You can run them using the script of the same name and the <code>-in</code> and
<code>-out</code> switches.  The scripts call <code>XSLTProcess</code> and specify the XSL
stylesheet with the <code>-xsl</code> switch.  You can do the same, if you want,
with either our stylesheets or your own.
</p>

<a name="TransitiveClosure" />
<h3>Transitive Closure</h3>
<a name="DependencyMetrics" />
<h3>Dependency Metrics</h3>

<hr />

<a name="OOMetrics" />
<h2>OO Metrics</h2>
<a name="Explanation" />
<h3>Explanation</h3>
<a name="ExtractingX" />
<h3>Extracting</h3>
<a name="ReportingX" />
<h3>Reporting</h3>
<a name="TextualOutputX" />
<h4>Textual Output</h4>
<a name="HTMLOutputX" />
<h4>HTML Output</h4>

<hr />

<a name="APIDifferencesX" />
<h2>API Differences</h2>

<p>
If you are developing libraries or frameworks, your clients depend on
your published set of APIs for their own development efforts.  It
becomes important, as you release new revisions of your software, to
keep track of which parts of the published API changed, so that you
can tell your clients how to upgrade their code.
</p>

<p>
Even if this is not your case, it is still a good practive to have a
look at what changed across your software since the latest baseline.
This allows you to keep track of changes to the classes and methods
and verify that they are evolving in the right direction, whichever
way you decide that is.
</p>

<a name="ExplanationX" />
<h3>Explanation</h3>

<p>
You can use <code>com.jeantessier.classreader.ClassfileLoader</code> classes to
examine the baseline of your codebase; be they in JAR files, loose
class files, or a combination of both.  You can apply the same treatment
to your latest codebase.  You now have two sets <code>Classfile</code> instances.
</p>

<p>
You can use <code>com.jeantessier.dependency.NodeFactory</code> to create a tree
of packages, classes, and features from each codebase.  You can then
start to compare them to each other.  If a package is in the old
codebase but not in the new one, you can mark it as having been removed.
If it is not in the old codebase but it is in new one, then you can
mark it as having been recently added.  For packages that are present
in both codebase, you can repeat this analysis at the class level, and
then at the feature level.
</p>

<a name="ExtractingXX" />
<h3>Extracting</h3>

<p>
You use <code>JarJarDiff</code> to extract API differences.  The following command
computes the API differences between versions <i>Old</i> and <i>New</i> of
<i>My Project</i>.  The differences are saved as an XML document in the file
<code>diff.xml</code>.
</p>

<pre>
    C:\>JarJarDiff -name "My Project"    \
                   -old-label Old        \
                   -old old.jar          \
                   -new-label New        \
	           -new new.jar          \
	           -out diff.xml
</pre>

<div align="center">
    <img src="images/ExtractingDifferences.gif" /><br />
<b>Extracting Differences</b>
</div>

<p>
You use <code>-old</code> switches to tell it where the <i>old</i>, or base version is
located.  Each <code>-old</code> switch can point to either a JAR file, a Zip file,
or a directory that will be searched for <code>.class</code> files.  You can
specify a label for the version with the <code>-old-label</code> switch.  If you
do not provide a label, the tool with create one by concatenating the
parameters to <code>-old</code> switches.
</p>

<p>
You use <code>-new</code> switches to tell it where the <i>new</i>, or modified version
is located.  Each <code>-new</code> switch can point to either a JAR file, a Zip
file, or a directory that will be searched for <code>.class</code> files.  You can
specify a label for the version with the <code>-new-label</code> switch.  If you
do not provide a label, the tool with create one by concatenating the
parameters to <code>-new</code> switches.
</p>

<p>
By default, the raw results are written in XML to the standard output
stream (i.e., <code>System.out</code>).  You can write it to a file by using the
<code>-out</code> switch.
</p>

<a name="ReportingXX" />
<h3>Reporting</h3>

<p>
Dependency Finder includes XSL stylesheets for representing differences
using HTML.  The stylesheets include:
</p>

<ul>
<li>DiffToHTML.xsl</li>
<li>PublishedDiffToHTML.xsl</li>
<li>ListDocumentationDiffToText.xsl</li>
<li>ListDocumentationDiffToHTML.xsl</li>
<li>ListInheritanceDiffToText.xsl</li>
</ul>

<p>
You can run them using the script of the same name and the <code>-in</code> and
<code>-out</code> switches.  The scripts call <code>XSLTProcess</code> and specify the XSL
stylesheet with the <code>-xsl</code> switch.  You can do the same, if you want,
with either our stylesheets or your own.
</p>

<a name="FullList" />
<h4>Full List</h4>

<p>
You use <code>DiffToHTML</code> to convert all API differences to HTML.  The
following command produces a full report from the output of the previous
<code>JarJarDiff</code> command.
</p>

<pre>
    C:\>DiffToHTML -in diff.xml          \
                   -out fullreport.html
</pre>

<div align="center">
    <img src="images/CompleteList.gif" /><br />
<b>Full List</b>
</div>

<a name="PublicList" />
<h4>Public List</h4>

<p>
You use <code>PublishedDiffToHTML</code> to convert only public API differences
to HTML.  The following command produces a full report from the output
of the previous <code>JarJarDiff</code> command.
</p>

<pre>
    C:\>PublishedDiffToHTML -in diff.xml                  \
                            -out publishedAPIreport.html
</pre>

<div align="center">
    <img src="images/PublicList.gif" /><br />
<b>Public List</b>
</div>

<a name="Filtering" />
<h4>Filtering</h4>

<p>
You can also limit the reporting to specific programming elements
that have been earmarked using special javadoc tags.
</p>

<p>
You get the list of earmarked elements by running a specialized
doclet.
</p>

<p>
The following commands run this doclet on the old as well as the
new codebases, saving the results in individual text files.
</p>

<pre>
    C:\>ListDocumentedElements -tag level         \
                               -valid published   \
                               -out old-list.txt  \
                               old.java
</pre>

<pre>
    C:\>ListDocumentedElements -tag level         \
                               -valid published   \
                               -out new-list.txt  \
                               new.java
</pre>

<div align="center">
    <img src="images/ListDocumentedElements.gif" /><br />
<b>Extracting Documented Elements</b>
</div>

<p>
You then feed the output from the doclet to <code>JarJarDiff</code>.
</p>

<pre>
    C:\>JarJarDiff -name "My Project"               \
                   -old-label Old                   \
                   -old old.jar                     \
	           -old-documentation old-list.txt  \
                   -new-label New                   \
	           -new new.jar                     \
	           -new-documentation new-list.txt  \
	           -out diff.xml
</pre>

<div align="center">
    <img src="images/ExtractingDifferencesAndDocumentationChanges.gif" /><br />
<b>Extracting Differences And Documented Elements</b>
</div>

<p>
The full list will include special sections that highlight
changes in what is no more part of the documentation and what
was newly added to the documentation.
</p>

<pre>
    C:\>DiffToHTML -in diff.xml          \
                   -out fullreport.html
</pre>

<div align="center">
    <img src="images/CompleteListOfDocumentedElements.gif" /><br />
<b>Full List Of Documented Elements</b>
</div>

<p>
The list can also be fed to <code>DiffToExternalHTML</code> to further
limit the changes to the published public API.
</p>

<pre>
    C:\>PublishedDiffToHTML -in diff.xml                         \
                            -param validation-list new-list.txt  \
                            -out publishedAPIreport.html
</pre>

<div align="center">
    <img src="images/PublicListOfDocumentedElements.gif" /><br />
<b>Public List Of Documented Elements</b>
</div>

<a name="ListingPublishedDocumentationChanges" />
<h4>Listing Published Documentation Changes</h4>

<p>
You use <code>ListDiff</code> to list changes in what is considered part of the
published API.  It only needs the lists generated by the doclet.  No
source or bytecode required.
</p>

<pre>
    C:\>ListDiff -name "My Project"  \
                 -old-label Old      \
                 -old old-list.txt   \
                 -new-label New      \
                 -new new-list.txt   \
                 -compress           \
                 -out listdiff.xml
</pre>

<div align="center">
    <img src="images/ListDiff.gif" /><br />
<b>Listing Differences in Documented Elements</b>
</div>

<p>
<code>ListDiff</code> writes in XML and you can convert this XML
into HTML with <code>ListDiffToHTML</code>, or to text with
<code>ListDiffToText</code>.
</p>

<pre>
    C:\>ListDiffToHTML -in listdiff.xml     \
                       -out docreport.html
</pre>

<div align="center">
    <img src="images/ListDiff2HTML.gif" /><br />
<b>Report on Differences in Documented Elements</b>
</div>

<dl>
    <dt>NOTE:</dt>
    <dd><i>You can also use <code>ListDocumentationDiffToText</code>
    and <code>ListDocumentationDiffToHTML</code> to extract similar
    information from the output of JarJarDiff.  The list
    is written in HTML.  But we recommend that you use
    <code>ListDiff</code> instead; it is faster and simpler.</i></dd>
</dl>

<hr />

<a name="BuildingDependencyFinder" />
<h2>Building Dependency Finder</h2>

<pre>
    C:\>ant
</pre>

<a name="CompilingaBuild" />
<h3>Compiling a Build</h3>

<pre>
    C:\>ant jar
    C:\>ant clean
    C:\>ant docs
    C:\>ant dist
    C:\>ant src
    C:\>ant war
</pre>

<p>
or
</p>

<pre>
    C:\>ant jar clean docs dist src war
</pre>

<a name="TestingtheBuild" />
<h3>Testing the Build</h3>

<pre>
    C:\>ant tests
    C:\>textjunit TestAll
</pre>

<hr />

<a name="Support" />
<h2>Support</h2>

<p>
Look at the current bug list on
<a href="http://sourceforge.net/projects/depfind">SourceForge</a>.  There is also
a help-oriented discussion forum.
</p>

<p>
You can also email me at
<a href="mailto://jeantessier@users.sourceforge.net">jeantessier at users.sourceforge.net</a>.
</p>

<hr />

</body>

</html>
